diff --git a/.idea/artifacts/DVBinspector_1_18_0_jar.xml b/.idea/artifacts/DVBinspector_1_18_0_jar.xml
new file mode 100644
index 0000000..5f1a38e
--- /dev/null
+++ b/.idea/artifacts/DVBinspector_1_18_0_jar.xml
@@ -0,0 +1,19 @@
+<component name="ArtifactManager">
+  <artifact type="jar" name="DVBinspector-1.18.0:jar">
+    <output-path>$PROJECT_DIR$/out/artifacts/DVBinspector_1_18_0_jar</output-path>
+    <root id="archive" name="DVBinspector-1.18.0.jar">
+      <element id="module-output" name="DVBinspector-1.18.0" />
+      <element id="extracted-dir" path="$PROJECT_DIR$/lib/commons-collections-3.2.2.jar" path-in-jar="/" />
+      <element id="extracted-dir" path="$PROJECT_DIR$/lib/commons-text-1.9.jar" path-in-jar="/" />
+      <element id="extracted-dir" path="$PROJECT_DIR$/lib/jlayer-1.0.1.4.jar" path-in-jar="/" />
+      <element id="extracted-dir" path="$PROJECT_DIR$/lib/commons-logging-1.2.jar" path-in-jar="/" />
+      <element id="extracted-dir" path="$PROJECT_DIR$/lib/jfreechart-1.5.3.jar" path-in-jar="/" />
+      <element id="extracted-dir" path="$PROJECT_DIR$/lib/opencsv-5.5.2.jar" path-in-jar="/" />
+      <element id="extracted-dir" path="$PROJECT_DIR$/lib/commons-beanutils-1.9.4.jar" path-in-jar="/" />
+      <element id="extracted-dir" path="$PROJECT_DIR$/lib/commons-lang3-3.12.0.jar" path-in-jar="/" />
+      <element id="extracted-dir" path="$PROJECT_DIR$/lib/commons-collections4-4.4.jar" path-in-jar="/" />
+      <element id="extracted-dir" path="$PROJECT_DIR$/DVBinspector.jar" path-in-jar="/" />
+      <element id="extracted-dir" path="$PROJECT_DIR$/DVBinspector-1.18.0.jar" path-in-jar="/" />
+    </root>
+  </artifact>
+</component>
\ No newline at end of file
diff --git a/.idea/uiDesigner.xml b/.idea/uiDesigner.xml
new file mode 100644
index 0000000..2b63946
--- /dev/null
+++ b/.idea/uiDesigner.xml
@@ -0,0 +1,124 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Palette2">
+    <group name="Swing">
+      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />
+      </item>
+      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />
+      </item>
+      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.svg" removable="false" auto-create-binding="false" can-attach-label="true">
+        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />
+        <initial-values>
+          <property name="text" value="Button" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="RadioButton" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="CheckBox" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="Label" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
+          <preferred-size width="200" height="200" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
+          <preferred-size width="200" height="200" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />
+      </item>
+      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">
+          <preferred-size width="-1" height="20" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />
+      </item>
+      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />
+      </item>
+    </group>
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
index 0000000..35eb1dd
--- /dev/null
+++ b/.idea/vcs.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/out/artifacts/DVBinspector_1_18_0_jar/DVBinspector-1.18.0.jar b/out/artifacts/DVBinspector_1_18_0_jar/DVBinspector-1.18.0.jar
new file mode 100644
index 0000000..d6df094
Binary files /dev/null and b/out/artifacts/DVBinspector_1_18_0_jar/DVBinspector-1.18.0.jar differ
diff --git a/out/production/DVBinspector-1.18.0/META-INF/MANIFEST.MF b/out/production/DVBinspector-1.18.0/META-INF/MANIFEST.MF
new file mode 100644
index 0000000..2e28642
--- /dev/null
+++ b/out/production/DVBinspector-1.18.0/META-INF/MANIFEST.MF
@@ -0,0 +1,3 @@
+Manifest-Version: 1.0
+Main-Class: nl.digitalekabeltelevisie.main.DVBinspector
+
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/PSI.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/PSI.class
index 0b7143c..20aab4e 100644
Binary files a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/PSI.class and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/PSI.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/PsiSectionData.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/PsiSectionData.class
index 6f324f0..ac143ab 100644
Binary files a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/PsiSectionData.class and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/PsiSectionData.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/TransportStream$ComponentType.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/TransportStream$ComponentType.class
index 4079d62..2f34945 100644
Binary files a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/TransportStream$ComponentType.class and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/TransportStream$ComponentType.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/TransportStream.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/TransportStream.class
index 0627b12..a41cf51 100644
Binary files a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/TransportStream.class and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/TransportStream.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/Descriptor.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/Descriptor.class
index 45b8547..e70da9c 100644
Binary files a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/Descriptor.class and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/Descriptor.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/DescriptorFactory.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/DescriptorFactory.class
index 5c7aabb..4ef82e7 100644
Binary files a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/DescriptorFactory.class and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/DescriptorFactory.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/AC3AudioDescriptor.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/AC3AudioDescriptor.class
new file mode 100644
index 0000000..7bb1695
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/AC3AudioDescriptor.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/CaptionServiceDescriptor$CaptionService.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/CaptionServiceDescriptor$CaptionService.class
new file mode 100644
index 0000000..942f62c
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/CaptionServiceDescriptor$CaptionService.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/CaptionServiceDescriptor.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/CaptionServiceDescriptor.class
new file mode 100644
index 0000000..22899d4
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/CaptionServiceDescriptor.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ContentAdvisoryDescriptor$RatingRegion$RatedDimension.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ContentAdvisoryDescriptor$RatingRegion$RatedDimension.class
new file mode 100644
index 0000000..dd79d8d
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ContentAdvisoryDescriptor$RatingRegion$RatedDimension.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ContentAdvisoryDescriptor$RatingRegion.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ContentAdvisoryDescriptor$RatingRegion.class
new file mode 100644
index 0000000..e7825a2
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ContentAdvisoryDescriptor$RatingRegion.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ContentAdvisoryDescriptor.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ContentAdvisoryDescriptor.class
new file mode 100644
index 0000000..f11946f
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ContentAdvisoryDescriptor.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/E_AC3AudioDescriptor.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/E_AC3AudioDescriptor.class
new file mode 100644
index 0000000..af9d745
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/E_AC3AudioDescriptor.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ExtendedChannelNameDescriptor$DescriptorString$DescriptorSegment.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ExtendedChannelNameDescriptor$DescriptorString$DescriptorSegment.class
new file mode 100644
index 0000000..e95aeba
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ExtendedChannelNameDescriptor$DescriptorString$DescriptorSegment.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ExtendedChannelNameDescriptor$DescriptorString.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ExtendedChannelNameDescriptor$DescriptorString.class
new file mode 100644
index 0000000..a2f6e98
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ExtendedChannelNameDescriptor$DescriptorString.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ExtendedChannelNameDescriptor.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ExtendedChannelNameDescriptor.class
new file mode 100644
index 0000000..f7edd85
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ExtendedChannelNameDescriptor.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/GenreDescriptor$Attribute.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/GenreDescriptor$Attribute.class
new file mode 100644
index 0000000..9ee0855
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/GenreDescriptor$Attribute.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/GenreDescriptor.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/GenreDescriptor.class
new file mode 100644
index 0000000..af4378b
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/GenreDescriptor.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MSSdescriptor$DescriptorString$DescriptorSegment.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MSSdescriptor$DescriptorString$DescriptorSegment.class
new file mode 100644
index 0000000..1424789
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MSSdescriptor$DescriptorString$DescriptorSegment.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MSSdescriptor$DescriptorString.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MSSdescriptor$DescriptorString.class
new file mode 100644
index 0000000..fcce717
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MSSdescriptor$DescriptorString.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MSSdescriptor.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MSSdescriptor.class
new file mode 100644
index 0000000..60f0ce3
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MSSdescriptor.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MultipleStringStructure$DescriptorString$DescriptorSegment.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MultipleStringStructure$DescriptorString$DescriptorSegment.class
new file mode 100644
index 0000000..1d49447
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MultipleStringStructure$DescriptorString$DescriptorSegment.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MultipleStringStructure$DescriptorString.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MultipleStringStructure$DescriptorString.class
new file mode 100644
index 0000000..c390930
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MultipleStringStructure$DescriptorString.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MultipleStringStructure.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MultipleStringStructure.class
new file mode 100644
index 0000000..2a386bd
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MultipleStringStructure.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/RedistributionControlDescriptor$RC_information.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/RedistributionControlDescriptor$RC_information.class
new file mode 100644
index 0000000..effdecb
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/RedistributionControlDescriptor$RC_information.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/RedistributionControlDescriptor.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/RedistributionControlDescriptor.class
new file mode 100644
index 0000000..e5cb571
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/RedistributionControlDescriptor.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ServiceLocationDescriptor$ElementaryStream.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ServiceLocationDescriptor$ElementaryStream.class
new file mode 100644
index 0000000..c69c784
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ServiceLocationDescriptor$ElementaryStream.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ServiceLocationDescriptor.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ServiceLocationDescriptor.class
new file mode 100644
index 0000000..6cd931d
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ServiceLocationDescriptor.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/TimeShiftedServiceDescriptor$TimeShiftedService.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/TimeShiftedServiceDescriptor$TimeShiftedService.class
new file mode 100644
index 0000000..cd9614c
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/TimeShiftedServiceDescriptor$TimeShiftedService.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/TimeShiftedServiceDescriptor.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/TimeShiftedServiceDescriptor.class
new file mode 100644
index 0000000..443eccc
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/TimeShiftedServiceDescriptor.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/CVCT.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/CVCT.class
new file mode 100644
index 0000000..03dd00e
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/CVCT.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/CVCTsection$VirtualChannel.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/CVCTsection$VirtualChannel.class
new file mode 100644
index 0000000..d8bccab
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/CVCTsection$VirtualChannel.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/CVCTsection.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/CVCTsection.class
new file mode 100644
index 0000000..cf4bb5a
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/CVCTsection.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/EITATSC.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/EITATSC.class
new file mode 100644
index 0000000..d67da08
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/EITATSC.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/EITsectionATSC$Event.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/EITsectionATSC$Event.class
new file mode 100644
index 0000000..f2163b8
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/EITsectionATSC$Event.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/EITsectionATSC.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/EITsectionATSC.class
new file mode 100644
index 0000000..f3619be
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/EITsectionATSC.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/ETT.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/ETT.class
new file mode 100644
index 0000000..05e0157
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/ETT.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/ETTsection.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/ETTsection.class
new file mode 100644
index 0000000..ea82cee
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/ETTsection.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/MGT.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/MGT.class
new file mode 100644
index 0000000..50f1efb
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/MGT.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/MGTsection$TablesInfo.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/MGTsection$TablesInfo.class
new file mode 100644
index 0000000..f907c16
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/MGTsection$TablesInfo.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/MGTsection.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/MGTsection.class
new file mode 100644
index 0000000..fb8948c
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/MGTsection.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/RRT.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/RRT.class
new file mode 100644
index 0000000..431c8d5
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/RRT.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/RRTsection$Dimension$Abbrev.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/RRTsection$Dimension$Abbrev.class
new file mode 100644
index 0000000..9a2f21b
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/RRTsection$Dimension$Abbrev.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/RRTsection$Dimension.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/RRTsection$Dimension.class
new file mode 100644
index 0000000..802aec5
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/RRTsection$Dimension.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/RRTsection.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/RRTsection.class
new file mode 100644
index 0000000..5fc71aa
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/RRTsection.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/STT.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/STT.class
new file mode 100644
index 0000000..477ba29
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/STT.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/STTsection.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/STTsection.class
new file mode 100644
index 0000000..aa23cc0
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/STTsection.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/TVCT.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/TVCT.class
new file mode 100644
index 0000000..a248d14
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/TVCT.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/TVCTsection$VirtualChannel.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/TVCTsection$VirtualChannel.class
new file mode 100644
index 0000000..f2338a3
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/TVCTsection$VirtualChannel.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/TVCTsection.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/TVCTsection.class
new file mode 100644
index 0000000..46bbdfe
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/TVCTsection.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/TableSection.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/TableSection.class
index a12088f..30a583a 100644
Binary files a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/TableSection.class and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/TableSection.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/handler/GeneralPsiTableHandler.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/handler/GeneralPsiTableHandler.class
index 642d732..e7aecba 100644
Binary files a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/handler/GeneralPsiTableHandler.class and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/data/mpeg/psi/handler/GeneralPsiTableHandler.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/gui/EITATSCView.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/gui/EITATSCView.class
new file mode 100644
index 0000000..e1e31ff
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/gui/EITATSCView.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/gui/EITATSCtableImage.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/gui/EITATSCtableImage.class
new file mode 100644
index 0000000..ac7348b
Binary files /dev/null and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/gui/EITATSCtableImage.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/gui/EITView.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/gui/EITView.class
index cbb65fd..aaf1782 100644
Binary files a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/gui/EITView.class and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/gui/EITView.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/gui/EITableImage.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/gui/EITableImage.class
index 758c540..c3d7984 100644
Binary files a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/gui/EITableImage.class and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/gui/EITableImage.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/main/DVBinspector.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/main/DVBinspector.class
index 8531ff5..0847965 100644
Binary files a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/main/DVBinspector.class and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/main/DVBinspector.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/util/Utils$1.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/util/Utils$1.class
index 53a77a1..1eb0683 100644
Binary files a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/util/Utils$1.class and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/util/Utils$1.class differ
diff --git a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/util/Utils.class b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/util/Utils.class
index 161d311..9c530c4 100644
Binary files a/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/util/Utils.class and b/out/production/DVBinspector-1.18.0/nl/digitalekabeltelevisie/util/Utils.class differ
diff --git a/src/main/java/META-INF/MANIFEST.MF b/src/main/java/META-INF/MANIFEST.MF
new file mode 100644
index 0000000..2e28642
--- /dev/null
+++ b/src/main/java/META-INF/MANIFEST.MF
@@ -0,0 +1,3 @@
+Manifest-Version: 1.0
+Main-Class: nl.digitalekabeltelevisie.main.DVBinspector
+
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/PSI.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/PSI.java
index 9c9aa32..713d481 100644
--- a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/PSI.java
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/PSI.java
@@ -65,7 +65,15 @@ public class PSI {
 	private final DFITs dfit_table = new DFITs(this);
 	
 	private final M7Fastscan m7fastscan = new M7Fastscan(this);
-	
+
+	//modify dinghang.men
+	private final STT stt = new STT(this);
+	private final TVCT tvct = new TVCT(this);
+	private final CVCT cvct = new CVCT(this);
+	private final MGT mgt = new MGT(this);
+	private final RRT rrt = new RRT(this);
+	private final EITATSC eitatsc = new EITATSC(this);
+	private final ETT ett = new ETT(this);
 
 	public DefaultMutableTreeNode getJTreeNode(final int modus){
 
@@ -92,6 +100,16 @@ public class PSI {
 		if(PreferencesManager.isEnableM7Fastscan()) {
 			t.add(m7fastscan.getJTreeNode(modus));
 		}
+
+		//modify dinghang.men
+		t.add(mgt.getJTreeNode(modus));
+		t.add(stt.getJTreeNode(modus));
+		t.add(tvct.getJTreeNode(modus));
+//		t.add(cvct.getJTreeNode(modus));
+		t.add(rrt.getJTreeNode(modus));
+		t.add(eitatsc.getJTreeNode_epg(modus));
+//		t.add(eitatsc.getJTreeNode(modus));
+		t.add(ett.getJTreeNode(modus));
 		return t;
 	}
 	public PMTs getPmts() {
@@ -183,4 +201,31 @@ public class PSI {
 	public TSDT getTsdt() {
 		return tsdt;
 	}
+
+	//modify dinghang.men
+	public STT getStt(){
+		return stt;
+	}
+
+	public TVCT getTvct(){
+		return tvct;
+	}
+
+	public CVCT getCvct(){
+		return cvct;
+	}
+	public MGT getMgt(){
+		return mgt;
+	}
+
+	public RRT getRrt() {
+		return rrt;
+	}
+
+	public EITATSC getEitatsc() {
+		return eitatsc;
+	}
+	public ETT getEtt(){
+		return ett;
+	}
 }
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/PsiSectionData.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/PsiSectionData.java
index 9e8ac8b..b64ae57 100644
--- a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/PsiSectionData.java
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/PsiSectionData.java
@@ -144,6 +144,25 @@ public class PsiSectionData {
 			} else {
 
 				final int tableId = Byte.toUnsignedInt(data[0]);
+				//modify  dinghang.men
+				if (tableId == 0xCD && pid == 0x1FFB) {
+					transportStream.getPsi().getStt().update(new STTsection(this,parentPID));
+				}else if(tableId == 0xC8 && pid == 0x1FFB){
+					transportStream.getPsi().getTvct().update(new TVCTsection(this,parentPID));
+				} else if(tableId == 0xC9 && pid == 0x1FFB){
+					transportStream.getPsi().getTvct().update(new TVCTsection(this,parentPID));
+//					transportStream.getPsi().getCvct().update(new CVCTsection(this,parentPID));
+				}else if(tableId == 0xC7 && pid == 0x1FFB){
+					transportStream.getPsi().getMgt().update(new MGTsection(this,parentPID));
+				} else if (tableId == 0xCA && pid == 0x1FFB) {
+					transportStream.getPsi().getRrt().update(new RRTsection(this,parentPID));
+				} else if (tableId == 0xCB) {
+					transportStream.getPsi().getEitatsc().update_epg(new EITsectionATSC(this,parentPID));
+//					transportStream.getPsi().getEitatsc().update(new EITsectionATSC(this,parentPID));
+				} else if (tableId == 0xCC) {
+					transportStream.getPsi().getEtt().update(new ETTsection(this,parentPID));
+				}
+
 				if((tableId==0x02)&&
 						(transportStream.getPsi().getPat().inPAT(pid))){
 					transportStream.getPsi().getPmts().update(new PMTsection(this,parentPID));
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/TransportStream.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/TransportStream.java
index ebcb671..2d52539 100644
--- a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/TransportStream.java
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/TransportStream.java
@@ -112,7 +112,11 @@ public class TransportStream implements TreeNode{
 		E_AC3("Enhanced Dolby Audio (AC3)"), 
 		VBI("VBI Data"), 
 		TELETEXT("Teletext"), 
-		DVB_SUBTITLING("DVB subtitling"), 
+		DVB_SUBTITLING("DVB subtitling"),
+
+		//modify  dinghang.men
+		ATSC("ATSC"),
+
 		AIT("Application Information Table (AIT)"), 
 		RCT("Related Content Table (RCT)"), 
 		T2MI("T2-MI"),
@@ -173,6 +177,7 @@ public class TransportStream implements TreeNode{
 	 * number of TSPackets that had Transport Error Indicator set.
 	 */
 	private int error_packets = 0;
+
 	/**
 	 * Bitrate based on the average of all PIDs that contain a PCR. This is the most accurate way to calculate the bit rate.
 	 */
@@ -590,7 +595,9 @@ public class TransportStream implements TreeNode{
 			return "DIT";
 		case 0x1f:
 			return "SIT";
-
+		//modify dinghang.men
+		case 0x1ffb:
+			return "STT";
 		default:
 			if(pid <= 0x1b){
 				return "reserved for future use";
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/Descriptor.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/Descriptor.java
index 69b886e..15289bd 100644
--- a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/Descriptor.java
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/Descriptor.java
@@ -354,6 +354,7 @@ public class Descriptor implements TreeNode {
 		kvp.addTableSource(tableSource,"");
 		final DefaultMutableTreeNode t = new DefaultMutableTreeNode(kvp);
 
+		if(descriptorTag == 1){return t;} //dinghang.men
 		addGeneralDescriptorInfo(modus, t);
 		return t;
 	}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/DescriptorFactory.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/DescriptorFactory.java
index 4062c02..312858b 100644
--- a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/DescriptorFactory.java
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/DescriptorFactory.java
@@ -35,6 +35,7 @@ import java.util.*;
 import java.util.logging.Logger;
 
 import nl.digitalekabeltelevisie.data.mpeg.descriptors.aitable.*;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.atsc.*;
 import nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.dvb.*;
 import nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.mpeg.*;
 import nl.digitalekabeltelevisie.data.mpeg.descriptors.intable.*;
@@ -110,6 +111,28 @@ public final class DescriptorFactory {
 		return r;
 	}
 
+	//new dinghang.men
+	public static List<Descriptor> buildMultipleStringStructure(final byte[] data, final int offset, final int len,
+																final TableSection tableSection) {
+		if(len == 0){
+			return null;
+		}
+		final List<Descriptor> r = new ArrayList<>();
+		Descriptor d = new MultipleStringStructure(data,offset,tableSection);
+		r.add(d);
+		return r;
+	}
+
+	public static List<MSSdescriptor> buildMSSdescriptor(final byte[] data, final int offset, final int len) {
+		if(len == 0){
+			return null;
+		}
+		final List<MSSdescriptor> r = new ArrayList<>();
+		MSSdescriptor m = new MSSdescriptor(data, offset);
+		r.add(m);
+		return r;
+	}
+
 	/**
 	 * @param localOffset
 	 * @param data
@@ -121,6 +144,36 @@ public final class DescriptorFactory {
 											DescriptorContext descriptorContext) {
 		final int descriptorTag = toUnsignedInt(data[0]);
 		try {
+			//modify dinghang.men
+			if(descriptorTag == 0xA0){
+				return new ExtendedChannelNameDescriptor(data,0,tableSection);
+			}
+			if(descriptorTag == 0xA1){
+				return new ServiceLocationDescriptor(data,0,tableSection);
+			}
+			if(descriptorTag == 0x87 && tableSection.getTableId() >= 0xC7 && tableSection.getTableId() <= 0xCD){
+				return new ContentAdvisoryDescriptor(data,0,tableSection);
+			}
+			if(descriptorTag == 0x86&& tableSection.getTableId() >= 0xC7 && tableSection.getTableId() <= 0xCD){
+				return new CaptionServiceDescriptor(data,0,tableSection);
+			}
+			if(descriptorTag == 0x81&& tableSection.getTableId() >= 0xC7 && tableSection.getTableId() <= 0xCD){
+				return new AC3AudioDescriptor(data,0,tableSection);
+			}
+			if(descriptorTag == 0xCC&& tableSection.getTableId() >= 0xC7 && tableSection.getTableId() <= 0xCD){
+				return new E_AC3AudioDescriptor(data,0,tableSection);
+			}
+			if(descriptorTag == 0xA2&& tableSection.getTableId() >= 0xC7 && tableSection.getTableId() <= 0xCD){
+				return new nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.atsc.TimeShiftedServiceDescriptor(data,0,tableSection);
+			}
+			if(descriptorTag == 0xAA&& tableSection.getTableId() >= 0xC7 && tableSection.getTableId() <= 0xCD){
+				return new RedistributionControlDescriptor(data,0,tableSection);
+			}
+			if(descriptorTag == 0xAB&& tableSection.getTableId() >= 0xC7 && tableSection.getTableId() <= 0xCD){
+				return new GenreDescriptor(data,0,tableSection);
+			}
+
+
 			if(descriptorTag == 0xE9) {
 				// OpenCable™ Specifications 
 				// Encoder Boundary Point Specification 
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/AC3AudioDescriptor.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/AC3AudioDescriptor.java
new file mode 100644
index 0000000..90544ae
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/AC3AudioDescriptor.java
@@ -0,0 +1,234 @@
+package nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.atsc;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.psi.TableSection;
+import nl.digitalekabeltelevisie.util.Utils;
+
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.util.Arrays;
+import java.util.List;
+
+public class AC3AudioDescriptor extends Descriptor {
+    private int sample_rate_code;
+    private int bsid;
+    private int bit_rate_code;
+    private int surround_mode;
+    private int bsmod;
+    private int num_channels;
+    private int full_svc;
+    private int langcod;
+    private int langcod2;
+    private int mainid;
+    private int priority;
+    private int asvcflags;
+    private int textlen;
+    private int text_code;
+    private byte[] text;
+    private int language_flag;
+    private int language_flag_2;
+    private byte[] language;
+    private byte[] language_2;
+    private byte[] additional_info;
+
+    /**
+     * @param b
+     * @param offset
+     * @param parent
+     */
+    public AC3AudioDescriptor(byte[] b, int offset, TableSection parent) {
+        super(b, offset, parent);
+        offset += 2;
+
+        byte temp1 = Arrays.copyOfRange(b,offset,offset+1)[0];
+        sample_rate_code = Utils.getBitsATSC(temp1,0,3);
+        bsid = Utils.getBitsATSC(temp1,3,5);
+        offset += 1;
+
+        byte temp2 = Arrays.copyOfRange(b,offset,offset+1)[0];
+        bit_rate_code = Utils.getBitsATSC(temp2,0,6);
+        surround_mode = Utils.getBitsATSC(temp2,6,2);
+        offset += 1;
+
+        byte temp3 = Arrays.copyOfRange(b,offset,offset+1)[0];
+        bsmod = Utils.getBitsATSC(temp3,0,3);
+        num_channels = Utils.getBitsATSC(temp3,3,4);
+        full_svc = Utils.getBitsATSC(temp3,7,1);
+        offset += 1;
+
+        langcod = Utils.getInt(b,offset,1,Utils.MASK_8BITS);
+        if(langcod == 255){
+            offset += 1;
+        }
+
+        if(num_channels == 0){
+            langcod2 = Utils.getInt(b,offset,1,Utils.MASK_8BITS);
+            offset += 1;
+        }
+
+        if(bsmod < 2){
+            byte temp4 = Arrays.copyOfRange(b,offset,offset+1)[0];
+            mainid = Utils.getBitsATSC(temp4,0,3);
+            priority = Utils.getBitsATSC(temp4,3,2);
+        }else{
+            asvcflags = Utils.getInt(b,offset,1,Utils.MASK_8BITS);
+        }
+        offset += 1;
+
+        byte temp5 = Arrays.copyOfRange(b,offset,offset+1)[0];
+        textlen = Utils.getBitsATSC(temp5,0,7);
+        text_code = Utils.getBitsATSC(temp5,7,1);
+        offset += 1;
+        text = Arrays.copyOfRange(b,offset,offset+textlen);
+        offset += textlen;
+
+        byte temp6 = Arrays.copyOfRange(b,offset,offset+1)[0];
+        language_flag = Utils.getBitsATSC(temp6,0,1);
+        language_flag_2 = Utils.getBitsATSC(temp6,1,1);
+        offset += 1;
+
+        if(language_flag == 1){
+            language = Arrays.copyOfRange(b,offset,offset+3);
+            offset += 3;
+        }
+        if(language_flag_2 == 1){
+            language_2 = Arrays.copyOfRange(b,offset,offset+3);
+            offset += 3;
+        }
+    }
+
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        final DefaultMutableTreeNode t = super.getJTreeNode(modus);
+        t.add(new DefaultMutableTreeNode(new KVP("sample_rate_code",sample_rate_code,explain_sample_rate_code(sample_rate_code))));
+        t.add(new DefaultMutableTreeNode(new KVP("bsid",bsid,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("bit_rate_code",bit_rate_code,explain_bit_rate_code(bit_rate_code))));
+        t.add(new DefaultMutableTreeNode(new KVP("surround_mode",surround_mode,explain_surround_mode(surround_mode))));
+        t.add(new DefaultMutableTreeNode(new KVP("bsmod",bsmod,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("num_channels",num_channels,explain_num_channels(num_channels))));
+        t.add(new DefaultMutableTreeNode(new KVP("full_svc",full_svc,null)));
+
+        if(langcod == 255){
+            t.add(new DefaultMutableTreeNode(new KVP("langcod",langcod,explain_langcod())));
+        }
+
+
+        if(num_channels == 0){
+            t.add(new DefaultMutableTreeNode(new KVP("langcod2",langcod2,null)));
+        }
+
+        if(bsmod < 2){
+            t.add(new DefaultMutableTreeNode(new KVP("mainid",mainid,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("priority",priority,explain_priority(priority))));
+        }else{
+            t.add(new DefaultMutableTreeNode(new KVP("asvcflags",asvcflags,null)));
+        }
+
+        t.add(new DefaultMutableTreeNode(new KVP("textlen",textlen,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("text_code",text_code,explain_text_code(text_code))));
+        t.add(new DefaultMutableTreeNode(new KVP("text",text,null)));
+
+        t.add(new DefaultMutableTreeNode(new KVP("language_flag",language_flag,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("language_flag_2",language_flag_2,null)));
+
+        if(language_flag == 1){
+            t.add(new DefaultMutableTreeNode(new KVP("language",language,null)));
+        }
+        if(language_flag_2 == 1){
+            t.add(new DefaultMutableTreeNode(new KVP("language_2",language_2,null)));
+        }
+        return t;
+    }
+
+    @Override
+    public String getDescriptorname(){
+        return "AC3 Audio Descriptor";
+    }
+
+    public static String explain_sample_rate_code(int sample_rate_code){
+        StringBuilder s = new StringBuilder();
+        switch (sample_rate_code){
+            case 0: return s.append("Sample Rate 48(kHz)").toString();
+            case 1: return s.append("Sample Rate 44.1(kHz)").toString();
+            case 2: return s.append("Sample Rate 32(kHz)").toString();
+            case 3: return s.append("Reserved").toString();
+            case 4: return s.append("Sample Rate 48 or 44.1(kHz)").toString();
+            case 5: return s.append("Sample Rate 48 or 32(kHz)").toString();
+            case 6: return s.append("Sample Rate 44.1 or 32(kHz)").toString();
+            case 7: return s.append("Sample Rate 48 or 44.1 or 32(kHz)").toString();
+            default: return s.toString();
+        }
+    }
+
+    public static String explain_bit_rate_code(int bit_rate_code){
+        StringBuilder s = new StringBuilder();
+        int[] rate = {32,40,48,56,
+                                64,80,96,112,
+                                128,160,192,224,
+                                256,320,384,448,
+                                512,576,640};
+        if(bit_rate_code >= 32 && bit_rate_code <= 50){
+            s.append("Bit Rate Upper Limit ");
+            bit_rate_code -= 32;
+            s.append(rate[bit_rate_code]);
+        } else if (bit_rate_code >= 0 && bit_rate_code <= 18) {
+            s.append("Exact Bit Rate ").append(rate[bit_rate_code]);
+        }
+        return s.append("(kbit/s)").toString();
+    }
+
+    public static String explain_surround_mode(int surround_mode){
+        StringBuilder s = new StringBuilder();
+        switch (surround_mode){
+            case 0:return s.append("Not indicated").toString();
+            case 1:return s.append("NOT Dolby surround encoded").toString();
+            case 2:return s.append("Dolby surround encoded").toString();
+            case 3:return s.append("Reserved").toString();
+            default:return s.toString();
+        }
+    }
+
+    public static String explain_num_channels (int num_channels){
+        StringBuilder s = new StringBuilder();
+        String[] list = {"1 + 1^2","1/0","2/0","3/0","2/1","3/1","2/2","3/2",
+                        "1","<=2","<=3","<=4","<=5","<=6","Reserved","Reserved"};
+        if(num_channels >= 0 && num_channels <= 7){
+            s.append("Audio coding mode (acmod) ").append(list[num_channels]);
+        } else if (num_channels >= 8 && num_channels <= 15) {
+            s.append("Number of encoded channels ").append(list[num_channels]);
+        }
+        return s.toString();
+    }
+
+    public static String explain_langcod (){
+        return "This field is deprecated. If langcod appears, it shall be set to 0XFF";
+    }
+
+    public static String explain_priority(int priority){
+        StringBuilder s = new StringBuilder();
+        if(priority == 0){
+            s.append("reserved");
+        }
+        if(priority == 1){
+            s.append("Primary Audio");
+        }
+        if(priority == 2){
+            s.append("Other Audio");
+        }
+        if(priority == 3){
+            s.append("Not specified");
+        }
+        return s.toString();
+    }
+
+    public static String explain_text_code(int text_code){
+        StringBuilder s = new StringBuilder();
+        if(text_code == 0){
+            s.append(" text is encoded as 1-byte characters using the ISO Latin-1 alphabet (ISO 8859-1)");
+        }
+        if(text_code == 1){
+            s.append(" text is encoded with 2-byte unicode characters.");
+        }
+        return s.toString();
+    }
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/CaptionServiceDescriptor.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/CaptionServiceDescriptor.java
new file mode 100644
index 0000000..e63d2e8
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/CaptionServiceDescriptor.java
@@ -0,0 +1,188 @@
+package nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.atsc;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.controller.TreeNode;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.psi.TableSection;
+import nl.digitalekabeltelevisie.util.Utils;
+
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class CaptionServiceDescriptor extends Descriptor {
+    private int number_of_services;
+    private List<CaptionService> captionServiceList;
+
+    /**
+     * @param b
+     * @param offset
+     * @param parent
+     */
+    public CaptionServiceDescriptor(byte[] b, int offset, TableSection parent) {
+        super(b, offset, parent);
+        offset += 2;
+        number_of_services = Utils.getInt(b,offset,1,Utils.MASK_5BITS);
+        offset += 1;
+        captionServiceList = new ArrayList<>();
+        for (int i = 0; i < number_of_services; i++) {
+            CaptionService captionService = new CaptionService();
+            captionService.setLanguage(Arrays.copyOfRange(b,offset,offset+3));
+            offset += 3;
+            byte temp = Arrays.copyOfRange(b,offset,offset+1)[0];
+            captionService.setDigital_cc(Utils.getBitATSC(temp,0));
+            if(captionService.getDigital_cc() == 0){
+                captionService.setLine21_field(Utils.getBitATSC(temp,7));
+            }else{
+                captionService.setCaption_service_number(Utils.getInt(b,offset,1,Utils.MASK_6BITS));
+            }
+            offset += 1;
+            byte[] be = Arrays.copyOfRange(b,offset,offset+2);
+            captionService.setEasy_reader(Utils.getBitsFromByteArray(be,0,1));
+            captionService.setWide_aspect_ratio(Utils.getBitsFromByteArray(be,1,1));
+            offset += 2;
+            captionServiceList.add(captionService);
+        }
+    }
+
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        final DefaultMutableTreeNode t = super.getJTreeNode(modus);
+        t.add(new DefaultMutableTreeNode(new KVP("number_of_services",number_of_services,null)));
+        Utils.addListJTree(t,captionServiceList,modus,"captionServiceList");
+        return t;
+    }
+
+    @Override
+    public String getDescriptorname(){
+        return "Caption Service Descriptor";
+    }
+
+    public class CaptionService implements TreeNode{
+        private byte[] language;
+        private int digital_cc;
+        private int line21_field;
+        private int caption_service_number;
+        private int easy_reader;
+        private int wide_aspect_ratio;
+
+        @Override
+        public DefaultMutableTreeNode getJTreeNode(int modus) {
+            final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("CaptionService"));
+            t.add(new DefaultMutableTreeNode(new KVP("language",language,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("digital_cc",digital_cc,explain_digital_cc(digital_cc))));
+            if(digital_cc == 0){
+                t.add(new DefaultMutableTreeNode(new KVP("line21_field",line21_field,null)));
+            }else{
+                t.add(new DefaultMutableTreeNode(new KVP("caption_service_number",caption_service_number,null)));
+            }
+            t.add(new DefaultMutableTreeNode(new KVP("easy_reader",easy_reader,explain_easy_reader(easy_reader,digital_cc))));
+            t.add(new DefaultMutableTreeNode(new KVP("wide_aspect_ratio",wide_aspect_ratio,explain_wide_aspect_ratio(wide_aspect_ratio,digital_cc))));
+            return t;
+        }
+
+        public byte[] getLanguage() {
+            return language;
+        }
+
+        public void setLanguage(byte[] language) {
+            this.language = language;
+        }
+
+        public int getDigital_cc() {
+            return digital_cc;
+        }
+
+        public void setDigital_cc(int digital_cc) {
+            this.digital_cc = digital_cc;
+        }
+
+        public int getLine21_field() {
+            return line21_field;
+        }
+
+        public void setLine21_field(int line21_field) {
+            this.line21_field = line21_field;
+        }
+
+        public int getCaption_service_number() {
+            return caption_service_number;
+        }
+
+        public void setCaption_service_number(int caption_service_number) {
+            this.caption_service_number = caption_service_number;
+        }
+
+        public int getEasy_reader() {
+            return easy_reader;
+        }
+
+        public void setEasy_reader(int easy_reader) {
+            this.easy_reader = easy_reader;
+        }
+
+        public int getWide_aspect_ratio() {
+            return wide_aspect_ratio;
+        }
+
+        public void setWide_aspect_ratio(int wide_aspect_ratio) {
+            this.wide_aspect_ratio = wide_aspect_ratio;
+        }
+    }
+
+    public int getNumber_of_services() {
+        return number_of_services;
+    }
+
+    public void setNumber_of_services(int number_of_services) {
+        this.number_of_services = number_of_services;
+    }
+
+    public List<CaptionService> getCaptionServiceList() {
+        return captionServiceList;
+    }
+
+    public void setCaptionServiceList(List<CaptionService> captionServiceList) {
+        this.captionServiceList = captionServiceList;
+    }
+
+    public static String explain_digital_cc(int digital_cc){
+        StringBuilder s = new StringBuilder();
+        if(digital_cc == 0){
+            s.append(" TYPE OF SERVICE 608");
+        }
+        if(digital_cc == 1){
+            s.append("TYPE OF SERVICE 708");
+        }
+        return s.toString();
+    }
+
+    public static String explain_wide_aspect_ratio(int wide_aspect_ratio, int digital_cc){
+        StringBuilder s = new StringBuilder();
+        if(digital_cc == 0){
+            return s.append("no meaning(digital_cc = 0)").toString();
+        }
+        if(wide_aspect_ratio == 0){
+            s.append("DISPLAY ASPECT RATIO 4:3");
+        }
+        if(wide_aspect_ratio == 1){
+            s.append("DISPLAY ASPECT RATIO 16:9");
+        }
+        return s.toString();
+    }
+
+    public static String explain_easy_reader(int easy_reader, int digital_cc){
+        StringBuilder s = new StringBuilder();
+        if(digital_cc == 0){
+            return s.append("no meaning(digital_cc = 0)").toString();
+        }
+        if(easy_reader == 0){
+            s.append("the closed caption service is not the EASY READER type");
+        }
+        if(easy_reader == 1){
+            s.append("the closed caption service is the EASY READER type");
+        }
+        return s.toString();
+    }
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ContentAdvisoryDescriptor.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ContentAdvisoryDescriptor.java
new file mode 100644
index 0000000..f13021f
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ContentAdvisoryDescriptor.java
@@ -0,0 +1,169 @@
+package nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.atsc;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.controller.TreeNode;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.DescriptorFactory;
+import nl.digitalekabeltelevisie.data.mpeg.psi.TableSection;
+import nl.digitalekabeltelevisie.util.Utils;
+
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.util.ArrayList;
+import java.util.List;
+
+public class ContentAdvisoryDescriptor extends Descriptor {
+    private int rating_region_count;
+    private List<RatingRegion> ratingRegionList;
+
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        final DefaultMutableTreeNode t = super.getJTreeNode(modus);
+        t.add(new DefaultMutableTreeNode(new KVP("rating_region",rating_region_count,null)));
+        Utils.addListJTree(t,ratingRegionList,modus,"ratingRegionList");
+        return t;
+    }
+
+    @Override
+    public String getDescriptorname(){
+        return "Content Advisory Descriptor";
+    }
+
+    /**
+     * @param b
+     * @param offset
+     * @param parent
+     */
+    public ContentAdvisoryDescriptor(byte[] b, int offset, TableSection parent) {
+        super(b, offset, parent);
+        offset += 2;
+        rating_region_count = Utils.getInt(b,offset,1,Utils.MASK_6BITS);
+        offset += 1;
+        ratingRegionList = new ArrayList<>();
+        for (int i = 0; i < rating_region_count; i++) {
+            RatingRegion ratingRegion = new RatingRegion();
+            ratingRegion.setRating_region(Utils.getInt(b,offset,1,Utils.MASK_8BITS));
+            offset += 1;
+            ratingRegion.setRated_dimensions(Utils.getInt(b,offset,1,Utils.MASK_8BITS));
+            offset += 1;
+            ratingRegion.rating_dimension_List = new ArrayList<>();
+            for (int j = 0; j < ratingRegion.getRated_dimensions(); j++) {
+                RatingRegion.RatedDimension ratedDimension = ratingRegion.new RatedDimension();
+                ratedDimension.setRating_dimension(Utils.getInt(b,offset,1,Utils.MASK_8BITS));
+                offset += 1;
+                ratedDimension.setRating_value(Utils.getInt(b,offset,1,Utils.MASK_4BITS));
+                offset += 1;
+                ratingRegion.rating_dimension_List.add(ratedDimension);
+            }
+            ratingRegion.setRating_description_length(Utils.getInt(b,offset,1,Utils.MASK_8BITS));
+            offset += 1;
+//            ratingRegion.rating_description_text = new ArrayList<>();
+//            TableSection tableSection = new TableSection(, parent);
+            ratingRegion.rating_description_text = DescriptorFactory.buildMSSdescriptor
+                    (b,offset,ratingRegion.getRating_description_length());
+            offset += ratingRegion.getRating_description_length();
+            ratingRegionList.add(ratingRegion);
+        }
+    }
+    public class RatingRegion implements TreeNode{
+        private int rating_region;
+        private int rated_dimensions;
+        private List<RatedDimension> rating_dimension_List;
+        private int rating_description_length;
+        private List<MSSdescriptor> rating_description_text;
+
+        @Override
+        public DefaultMutableTreeNode getJTreeNode(int modus) {
+            final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("RatingRegion"));
+            t.add(new DefaultMutableTreeNode(new KVP("rating_region",rating_region,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("rated_dimensions",rated_dimensions,null)));
+            Utils.addListJTree(t,rating_dimension_List,modus,"rating_dimension_List");
+            t.add(new DefaultMutableTreeNode(new KVP("rating_description_length",rating_description_length,null)));
+            Utils.addListJTree(t,rating_description_text,modus,"rating_description_text");
+            return t;
+        }
+        public class RatedDimension implements TreeNode{
+            private int rating_dimension;
+            private int rating_value;
+
+            @Override
+            public DefaultMutableTreeNode getJTreeNode(int modus) {
+                final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("RatedDimensions"));
+                t.add(new DefaultMutableTreeNode(new KVP("rating_dimension",rating_dimension,null)));
+                t.add(new DefaultMutableTreeNode(new KVP("rating_value",rating_value,null)));
+                return t;
+            }
+
+            public int getRating_dimension() {
+                return rating_dimension;
+            }
+
+            public void setRating_dimension(int rating_dimension) {
+                this.rating_dimension = rating_dimension;
+            }
+
+            public int getRating_value() {
+                return rating_value;
+            }
+
+            public void setRating_value(int rating_value) {
+                this.rating_value = rating_value;
+            }
+        }
+
+        public int getRating_region() {
+            return rating_region;
+        }
+
+        public void setRating_region(int rating_region) {
+            this.rating_region = rating_region;
+        }
+
+        public int getRated_dimensions() {
+            return rated_dimensions;
+        }
+
+        public void setRated_dimensions(int rated_dimensions) {
+            this.rated_dimensions = rated_dimensions;
+        }
+
+        public List<RatedDimension> getRating_region_List() {
+            return rating_dimension_List;
+        }
+
+        public void setRating_region_List(List<RatedDimension> rating_region_List) {
+            this.rating_dimension_List = rating_region_List;
+        }
+
+        public int getRating_description_length() {
+            return rating_description_length;
+        }
+
+        public void setRating_description_length(int rating_description_length) {
+            this.rating_description_length = rating_description_length;
+        }
+
+        public List<MSSdescriptor> getRating_description_text() {
+            return rating_description_text;
+        }
+
+        public void setRating_description_text(List<MSSdescriptor> rating_description_text) {
+            this.rating_description_text = rating_description_text;
+        }
+    }
+
+    public int getRating_region_count() {
+        return rating_region_count;
+    }
+
+    public void setRating_region_count(int rating_region_count) {
+        this.rating_region_count = rating_region_count;
+    }
+
+    public List<RatingRegion> getRatingRegionList() {
+        return ratingRegionList;
+    }
+
+    public void setRatingRegionList(List<RatingRegion> ratingRegionList) {
+        this.ratingRegionList = ratingRegionList;
+    }
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/E_AC3AudioDescriptor.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/E_AC3AudioDescriptor.java
new file mode 100644
index 0000000..640fc9f
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/E_AC3AudioDescriptor.java
@@ -0,0 +1,280 @@
+package nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.atsc;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.AC3Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.pes.ac3.AbstractAC3SyncFrame;
+import nl.digitalekabeltelevisie.data.mpeg.psi.TableSection;
+import nl.digitalekabeltelevisie.util.Utils;
+
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.util.Arrays;
+
+public class E_AC3AudioDescriptor extends Descriptor {
+    //按照标准，以下为必须字段
+    private int bsid_flag;
+    private int mainid_flag;
+    private int asvc_flag;
+    private int mixinfoexists;
+    private int substream1_flag;
+    private int substream2_flag;
+    private int substream3_flag;
+    private int full_service_flag;
+    private int audio_service_type;
+    private int number_of_channels;
+    private int language_flag;
+    private int language_flag_2;
+
+
+    //根据标准，以下字段由相应必须字段决定是否存在
+    private int bsid;
+    private int zero_bits;
+
+    private int priority;
+    private int mainid;
+
+    private int asvc;
+
+    private int substream1;
+    private int substream2;
+    private int substream3;
+
+    private byte[] language;
+    private byte[] language_2;
+
+    private byte[] substream1_lang;
+    private byte[] substream2_lang;
+    private byte[] substream3_lang;
+    private byte[] additional_info_byte;
+
+    /**
+     * @param b
+     * @param offset
+     * @param parent
+     */
+    public E_AC3AudioDescriptor(byte[] b, int offset, TableSection parent) {
+        super(b, offset, parent);
+        offset += 2;
+
+        byte temp1 = Arrays.copyOfRange(b,offset,offset+1)[0];
+        bsid_flag = Utils.getBitATSC(temp1,1);
+        mainid_flag = Utils.getBitATSC(temp1,2);
+        asvc_flag = Utils.getBitATSC(temp1,3);
+        mixinfoexists = Utils.getBitATSC(temp1,4);
+        substream1_flag = Utils.getBitATSC(temp1,5);
+        substream2_flag = Utils.getBitATSC(temp1,6);
+        substream3_flag = Utils.getBitATSC(temp1,7);
+        offset += 1;
+
+        byte temp2 = Arrays.copyOfRange(b,offset,offset+1)[0];
+        full_service_flag = Utils.getBitATSC(temp2,1);
+        audio_service_type = Utils.getBitsATSC(temp2,2,3);
+        number_of_channels = Utils.getBitsATSC(temp2,5,3);
+        offset += 1;
+
+        byte temp3 = Arrays.copyOfRange(b,offset,offset+1)[0];
+        language_flag = Utils.getBitATSC(temp3,0);
+        language_flag_2 = Utils.getBitATSC(temp3,1);
+        if(bsid_flag == 1){
+            bsid = Utils.getBitsATSC(temp3,3,5);
+        }else{
+            zero_bits = Utils.getBitsATSC(temp3,3,5);
+        }
+        offset += 1;
+
+        if(mainid_flag == 1){
+            byte temp = Arrays.copyOfRange(b,offset,offset+1)[0];
+            priority = Utils.getBitsATSC(temp,3,2);
+            mainid = Utils.getBitsATSC(temp,5,3);
+            offset += 1;
+        }
+
+        if(asvc_flag == 1){
+            asvc = Utils.getInt(b,offset,1,Utils.MASK_8BITS);
+            offset += 1;
+        }
+
+        if(substream1_flag == 1){
+            substream1 = Utils.getInt(b,offset,1,Utils.MASK_8BITS);
+            offset += 1;
+        }
+        if(substream2_flag == 1){
+            substream2 = Utils.getInt(b,offset,1,Utils.MASK_8BITS);
+            offset += 1;
+        }
+        if(substream3_flag == 1){
+            substream3 = Utils.getInt(b,offset,1,Utils.MASK_8BITS);
+            offset += 1;
+        }
+
+        if(language_flag == 1){
+            language = Arrays.copyOfRange(b,offset,offset+3);
+            offset += 3;
+        }
+        if(language_flag_2 == 1){
+            language_2 = Arrays.copyOfRange(b,offset,offset+3);
+            offset += 3;
+        }
+
+        if(substream1_flag == 1){
+            substream1_lang = Arrays.copyOfRange(b,offset,offset+3);
+            offset += 3;
+        }
+        if(substream2_flag == 1){
+            substream2_lang = Arrays.copyOfRange(b,offset,offset+3);
+            offset += 3;
+        }
+        if(substream3_flag == 1){
+            substream3_lang = Arrays.copyOfRange(b,offset,offset+3);
+            offset += 3;
+        }
+    }
+
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(final int modus){
+
+        final DefaultMutableTreeNode t = super.getJTreeNode(modus);
+        t.add(new DefaultMutableTreeNode(new KVP("bsid_flag",bsid_flag,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("mainid_flag",mainid_flag,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("asvc_flag",asvc_flag,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("mixinfoexists",mixinfoexists,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("substream1_flag",substream1_flag,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("substream2_flag",substream2_flag,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("substream3_flag",substream3_flag,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("full_service_flag",full_service_flag,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("audio_service_type",audio_service_type,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("number_of_channels",number_of_channels,null)));
+
+        t.add(new DefaultMutableTreeNode(new KVP("language_flag",language_flag,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("language_flag_2",language_flag_2,null)));
+        if(bsid_flag!=0){
+            t.add(new DefaultMutableTreeNode(new KVP("bsid",bsid, AbstractAC3SyncFrame.getBsidString(bsid))));
+        }else{
+            t.add(new DefaultMutableTreeNode(new KVP("zero_bits",zero_bits, null)));
+        }
+
+        if(mainid_flag!=0){
+            t.add(new DefaultMutableTreeNode(new KVP("priority",priority,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("mainid",mainid,null)));
+        }
+        if(asvc_flag!=0){
+            t.add(new DefaultMutableTreeNode(new KVP("asvc",asvc,null)));
+        }
+
+        if(substream1_flag!=0){
+            t.add(new DefaultMutableTreeNode(new KVP("substream1",substream1,"type of audio carried in independent substream 1 of the Enhanced AC-3 elementary stream")));
+        }
+        if(substream2_flag!=0){
+            t.add(new DefaultMutableTreeNode(new KVP("substream2",substream2,"type of audio carried in independent substream 2 of the Enhanced AC-3 elementary stream")));
+        }
+        if(substream3_flag!=0){
+            t.add(new DefaultMutableTreeNode(new KVP("substream3",substream3,"type of audio carried in independent substream 3 of the Enhanced AC-3 elementary stream")));
+        }
+
+        if(language_flag!=0){
+            t.add(new DefaultMutableTreeNode(new KVP("language",language,"type of audio carried in independent substream 2 of the Enhanced AC-3 elementary stream")));
+        }
+        if(language_flag_2!=0){
+            t.add(new DefaultMutableTreeNode(new KVP("language_2",language_2,"type of audio carried in independent substream 3 of the Enhanced AC-3 elementary stream")));
+        }
+
+        if(substream1_flag!=0){
+            t.add(new DefaultMutableTreeNode(new KVP("substream2_lang",substream1_lang,"type of audio carried in independent substream 1 of the Enhanced AC-3 elementary stream")));
+        }
+        if(substream2_flag!=0){
+            t.add(new DefaultMutableTreeNode(new KVP("substream2_lang",substream2_lang,"type of audio carried in independent substream 2 of the Enhanced AC-3 elementary stream")));
+        }
+        if(substream3_flag!=0){
+            t.add(new DefaultMutableTreeNode(new KVP("substream3_lang",substream3_lang,"type of audio carried in independent substream 3 of the Enhanced AC-3 elementary stream")));
+        }
+
+        if(additional_info_byte!=null){
+            t.add(new DefaultMutableTreeNode(new KVP("additional_info_byte",additional_info_byte,null)));
+        }
+
+        return t;
+    }
+
+    @Override
+    public String getDescriptorname(){
+        return "E_AC3 Audio Descriptor";
+    }
+
+    public static String explain_audio_service_type(int audio_service_type){
+        StringBuilder s = new StringBuilder();
+        switch (audio_service_type){
+            case 0:return s.append("Complete Main (CM)").toString();
+            case 1:return s.append("Music and Effects (ME)").toString();
+            case 2:return s.append("Visually Impaired (VI)").toString();
+            case 3:return s.append("Hearing Impaired (HI)").toString();
+            case 4:return s.append("Dialogue (D)").toString();
+            case 5:return s.append("Commentary (C)").toString();
+            case 6:return s.append("Emergency (E)").toString();
+            case 7:return s.append("ReservedVoiceover (VO)/Karaoke").toString();
+            default:return s.toString();
+        }
+    }
+
+    public static String explain_number_of_channels(int number_of_channels){
+        StringBuilder s = new StringBuilder();
+        switch (number_of_channels){
+            case 0:return s.append("Mono").toString();
+            case 1:return s.append("1+1 Mode").toString();
+            case 2:return s.append("2-channel (stereo)").toString();
+            case 3:return s.append("2-channel Dolby Surround encoded (stereo)").toString();
+            case 4:return s.append("Multichannel audio  (> 2 channels; <= 3/2 + LFE channels").toString();
+            case 5:return s.append("Multichannel audio (> 3/2 + LFE channels)").toString();
+            case 6:
+            case 7:return s.append("reserved for future use").toString();
+            default:return s.toString();
+        }
+    }
+
+    public static String explain_substream(int substream){
+        StringBuilder s = new StringBuilder();
+        byte temp;
+        if(substream >=0 && substream <=255){
+            temp = (byte) substream;
+        }else{
+            return s.toString();
+        }
+
+        int substream_priority = Utils.getBitATSC(temp,1);
+        s.append("substream_priority = ").append(substream_priority);
+
+        int audio_service_type_flags = Utils.getBitsATSC(temp,2,3);
+        int number_of_channels_flags = Utils.getBitsATSC(temp,5,3);
+
+        s.append(", audio_service_type_flags = ").append(audio_service_type_flags);
+        switch (audio_service_type_flags){
+            case 0:s.append("(reserved) ");break;
+            case 1:s.append("(Music and Effects (ME))");break;
+            case 2:s.append("(Visually Impaired (VI))");break;
+            case 3:s.append("(Hearing Impaired (HI))");break;
+            case 4:s.append("(Dialogue (D))");break;
+            case 5:s.append("(Commentary (C))");break;
+            case 6:s.append("(reserved)");break;
+            case 7:s.append("(Voiceover (VO))");break;
+            default:
+        }
+
+        s.append(", number_of_channels_flags =").append(audio_service_type_flags);
+        switch (audio_service_type_flags){
+            case 0:s.append("(Mono) ");break;
+            case 1:s.append("(reserved for future use)");break;
+            case 2:s.append("(2 channel (stereo))");break;
+            case 3:s.append("(2 channel Dolby Surround encoded (stereo) )");break;
+            case 4:s.append("(Multichannel audio (> 2 channels; <= 3/2 + LFE channels))");break;
+            case 5:
+            case 6:
+            case 7:s.append("(reserved for future use )");break;
+            default:
+        }
+        return s.toString();
+
+    }
+
+
+
+
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ExtendedChannelNameDescriptor.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ExtendedChannelNameDescriptor.java
new file mode 100644
index 0000000..2236acc
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ExtendedChannelNameDescriptor.java
@@ -0,0 +1,233 @@
+package nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.atsc;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.controller.TreeNode;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.psi.TableSection;
+import nl.digitalekabeltelevisie.util.Utils;
+
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class ExtendedChannelNameDescriptor extends Descriptor {
+    private int number_strings;
+
+    private List<DescriptorString> descriptorStringList;
+
+    public class DescriptorString implements TreeNode{
+        private byte[] ISO_639_language_code;
+        private int number_segments;
+        private List<DescriptorSegment> segmentList;
+
+        @Override
+        public DefaultMutableTreeNode getJTreeNode(int modus) {
+            final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("DescriptorString"));
+            t.add(new DefaultMutableTreeNode(new KVP("ISO_639_language_code",ISO_639_language_code,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("number_segments",number_segments,null)));
+            Utils.addListJTree(t,segmentList,modus,"segmentList");
+            return t;
+        }
+
+        public class DescriptorSegment implements TreeNode{
+            private int compression_type;
+            private byte[] mode;
+            private int number_bytes;
+            private byte[] compressed_string_byte;
+
+
+
+            @Override
+            public DefaultMutableTreeNode getJTreeNode(int modus) {
+                final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("DescriptorSegment"));
+                t.add(new DefaultMutableTreeNode(new KVP("compression_type",compression_type,explain_compression_type(compression_type))));
+                t.add(new DefaultMutableTreeNode(new KVP("mode",mode,explain_modes(mode))));
+                t.add(new DefaultMutableTreeNode(new KVP("number_bytes",number_bytes,null)));
+                t.add(new DefaultMutableTreeNode(new KVP("compressed_string_byte",compressed_string_byte,null)));
+                return t;
+            }
+
+            public int getCompression_type() {
+                return compression_type;
+            }
+
+            public void setCompression_type(int compression_type) {
+                this.compression_type = compression_type;
+            }
+
+            public byte[] getMode() {
+                return mode;
+            }
+
+            public void setMode(byte[] mode) {
+                this.mode = mode;
+            }
+
+            public int getNumber_bytes() {
+                return number_bytes;
+            }
+
+            public void setNumber_bytes(int number_bytes) {
+                this.number_bytes = number_bytes;
+            }
+
+            public byte[] getCompressed_string_byte() {
+                return compressed_string_byte;
+            }
+
+            public void setCompressed_string_byte(byte[] compressed_string_byte) {
+                this.compressed_string_byte = compressed_string_byte;
+            }
+        }
+
+        public byte[] getISO_639_language_code() {
+            return ISO_639_language_code;
+        }
+
+        public void setISO_639_language_code(byte[] ISO_639_language_code) {
+            this.ISO_639_language_code = ISO_639_language_code;
+        }
+
+        public int getNumber_segments() {
+            return number_segments;
+        }
+
+        public void setNumber_segments(int number_segments) {
+            this.number_segments = number_segments;
+        }
+
+        public List<DescriptorSegment> getSegmentList() {
+            return segmentList;
+        }
+
+        public void setSegmentList(List<DescriptorSegment> segmentList) {
+            this.segmentList = segmentList;
+        }
+    }
+
+    /**
+     * @param b
+     * @param offset
+     * @param parent
+     */
+    public ExtendedChannelNameDescriptor(byte[] b, int offset, TableSection parent) {
+        super(b, offset, parent);
+        int current_offset = offset+2;
+        number_strings = Utils.getInt(b,current_offset,1,Utils.MASK_8BITS);
+        current_offset += 1;
+
+        descriptorStringList = new ArrayList<>();
+
+        for (int i = 0; i < number_strings; i++) {
+            DescriptorString descriptorString = new DescriptorString();
+            descriptorString.setISO_639_language_code(Arrays.copyOfRange(b,current_offset,current_offset+3));
+            current_offset += 3;
+            descriptorString.setNumber_segments(Utils.getInt(b,current_offset,1,Utils.MASK_8BITS));
+            current_offset += 1;
+            descriptorString.segmentList = new ArrayList<>();
+            for (int j = 0; j < descriptorString.getNumber_segments(); j++) {
+                DescriptorString.DescriptorSegment descriptorSegment = descriptorString.new DescriptorSegment();
+//                descriptorSegment.setCompression_type(Arrays.copyOfRange(b,current_offset,current_offset + 1));
+                descriptorSegment.setCompression_type(Utils.getInt(b,current_offset,1,Utils.MASK_8BITS));
+                current_offset += 1;
+                descriptorSegment.setMode(Arrays.copyOfRange(b,current_offset,current_offset + 1));
+                current_offset += 1;
+                descriptorSegment.setNumber_bytes(Utils.getInt(b,current_offset,1,Utils.MASK_8BITS));
+                current_offset += 1;
+                descriptorSegment.setCompressed_string_byte(Arrays.copyOfRange
+                        (b,current_offset,current_offset + descriptorSegment.getNumber_bytes()));
+                current_offset += descriptorSegment.getNumber_bytes();
+                descriptorString.segmentList.add(descriptorSegment);
+            }
+            descriptorStringList.add(descriptorString);
+        }
+    }
+
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        final DefaultMutableTreeNode t = super.getJTreeNode(modus);
+        t.add(new DefaultMutableTreeNode(new KVP("number_strings",number_strings,null)));
+        Utils.addListJTree(t,descriptorStringList,modus,"descriptorStringList");
+        return t;
+    }
+
+    @Override
+    public String getDescriptorname(){
+        return "Channel Name Descriptor";
+    }
+
+    public static String explain_compression_type(int compression_type){
+        StringBuilder s = new StringBuilder();
+        if(compression_type == 0){
+            s.append("No compression");
+        }
+        if(compression_type == 1){
+            s.append("Huffman coding");
+        }
+        if(compression_type == 2){
+            s.append("Huffman coding");
+        }
+        if(compression_type >= 3 && compression_type <= 175){
+            s.append("reserved");
+        }
+        if(compression_type >= 176 && compression_type <= 255){
+            s.append("Used in other systems");
+        }
+        return s.toString();
+    }
+
+    public static String explain_modes(byte[] modes){
+        int modes_number = Utils.getInt(modes,0,modes.length,Utils.MASK_8BITS);
+        StringBuilder s = new StringBuilder();
+        switch (modes_number){
+            case 0: return s.append("Select Unicode Code Range 0x0000 – 0x00FF").toString();
+            case 1: return s.append("Select Unicode Code Range 0x0100 – 0x01FF ").toString();
+            case 2: return s.append("Select Unicode Code Range 0x0200 – 0x02FF ").toString();
+            case 3: return s.append("Select Unicode Code Range 0x0300 – 0x03FF ").toString();
+            case 4: return s.append("Select Unicode Code Range 0x0400 – 0x04FF").toString();
+            case 5: return s.append("Select Unicode Code Range 0x0500 – 0x05FF").toString();
+            case 6: return s.append("Select Unicode Code Range 0x0600 – 0x06FF ").toString();
+//            case 7:
+//            case 8: return s.append("Reserved").toString();
+            case 9: return s.append("Select Unicode Code Range 0x0900 – 0x09FF ").toString();
+            case 10: return s.append("Select Unicode Code Range 0x0A00 – 0x0AFF ").toString();
+            case 11: return s.append("Select Unicode Code Range 0x0B00 – 0x0BFF ").toString();
+            case 12: return s.append("Select Unicode Code Range 0x0C00 – 0x0CFF  ").toString();
+            case 13: return s.append("Select Unicode Code Range 0x0D00 – 0x0DFF  ").toString();
+            case 14: return s.append("Select Unicode Code Range 0x0E00 – 0x0EFF").toString();
+            case 15: return s.append("Select Unicode Code Range 0x0F00 – 0x0FFF").toString();
+            case 16: return s.append("Select Unicode Code Range 0x1000 – 0x10FF ").toString();
+
+            case 32: return s.append("Select Unicode Code Range 0x2000 – 0x20FF ").toString();
+            case 33: return s.append("Select Unicode Code Range 0x2100 – 0x21FF ").toString();
+            case 34: return s.append("Select Unicode Code Range 0x2200 – 0x22FF ").toString();
+            case 35: return s.append("Select Unicode Code Range 0x2300 – 0x23FF ").toString();
+            case 36: return s.append("Select Unicode Code Range 0x2400 – 0x24FF  ").toString();
+            case 37: return s.append("Select Unicode Code Range 0x2500 – 0x25FF  ").toString();
+            case 38: return s.append("Select Unicode Code Range 0x2600 – 0x26FF").toString();
+            case 39: return s.append("Select Unicode Code Range 0x2700 – 0x27FF").toString();
+
+            case 48: return s.append("Select Unicode Code Range 0x3000 – 0x30FF  ").toString();
+            case 49: return s.append("Select Unicode Code Range 0x3100 – 0x31FF  ").toString();
+            case 50: return s.append("Select Unicode Code Range 0x3200 – 0x32FF").toString();
+            case 51: return s.append("Select Unicode Code Range 0x3300 – 0x33FF").toString();
+
+            case 62: return s.append("Select Standard Compression Scheme for Unicode (SCSU)").toString();
+            case 63: return s.append("Select Unicode, UTF-16 Form").toString();
+            case 64:
+            case 65: return s.append("Assigned to ATSC standard for Taiwan").toString();
+            case 66:
+            case 67:
+            case 68:
+            case 69:
+            case 70:
+            case 71: return s.append("Reserved for future ATSC use").toString();
+            case 72: return s.append("Assigned to ATSC standard for South Korea").toString();
+
+            case 255: return s.append("Not applicable").toString();
+
+            default: return s.append("Reserved").toString();
+        }
+    }
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/GenreDescriptor.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/GenreDescriptor.java
new file mode 100644
index 0000000..45e66b4
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/GenreDescriptor.java
@@ -0,0 +1,97 @@
+package nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.atsc;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.controller.TreeNode;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.psi.TableSection;
+import nl.digitalekabeltelevisie.util.Utils;
+
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.util.ArrayList;
+import java.util.List;
+
+public class  GenreDescriptor  extends Descriptor {
+
+    private int attribute_count;
+    private List<Attribute> attributeList;
+
+
+    /**
+     * @param b
+     * @param offset
+     * @param parent
+     */
+    public GenreDescriptor(byte[] b, int offset, TableSection parent) {
+        super(b, offset, parent);
+        offset += 2;
+        attribute_count = Utils.getInt(b,offset,1,Utils.MASK_5BITS);
+        offset += 1;
+        attributeList = new ArrayList<>();
+        for (int i = 0; i < attribute_count; i++) {
+            Attribute attribute = new Attribute();
+            attribute.setAttribute(Utils.getInt(b,offset,1,Utils.MASK_8BITS));
+            offset += 1;
+            attributeList.add(attribute);
+        }
+
+    }
+
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        final DefaultMutableTreeNode t = super.getJTreeNode(modus);
+        t.add(new DefaultMutableTreeNode(new KVP("attribute_count",attribute_count,null)));
+        Utils.addListJTree(t,attributeList,modus,"attributeList");
+        return t;
+    }
+
+    @Override
+    public String getDescriptorname(){
+        return "Redistribution Control Descriptor ";
+    }
+
+    public class Attribute implements TreeNode{
+        private int attribute;
+
+        @Override
+        public DefaultMutableTreeNode getJTreeNode(int modus) {
+            final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("attribute"));
+            t.add(new DefaultMutableTreeNode(new KVP("attribute",attribute,explain_attribute(attribute))));
+            return t;
+        }
+
+        public int getAttribute() {
+            return attribute;
+        }
+
+        public void setAttribute(int attribute) {
+            this.attribute = attribute;
+        }
+    }
+
+    public int getAttribute_count() {
+        return attribute_count;
+    }
+
+    public void setAttribute_count(int attribute_count) {
+        this.attribute_count = attribute_count;
+    }
+
+    public List<Attribute> getAttributeList() {
+        return attributeList;
+    }
+
+    public void setAttributeList(List<Attribute> attributeList) {
+        this.attributeList = attributeList;
+    }
+
+    public static String explain_attribute(int attribute){
+        StringBuilder s = new StringBuilder();
+        switch (attribute){
+            case 0:return s.append("Not Available").toString();
+            case 32:return s.append("Education").toString();
+            case 33:return s.append("Entertainment").toString();
+            case 34:return s.append("Movie").toString();
+            default:return s.toString();
+        }
+    }
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MSSdescriptor.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MSSdescriptor.java
new file mode 100644
index 0000000..7d0411e
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MSSdescriptor.java
@@ -0,0 +1,265 @@
+package nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.atsc;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.controller.TreeNode;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.psi.TableSection;
+import nl.digitalekabeltelevisie.util.Utils;
+
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class MSSdescriptor implements TreeNode{
+    private int number_strings;
+
+    private List<DescriptorString> descriptorStringList;
+
+    public class DescriptorString implements TreeNode{
+        private byte[] ISO_639_language_code;
+        private int number_segments;
+        private List<DescriptorSegment> segmentList;
+
+        @Override
+        public DefaultMutableTreeNode getJTreeNode(int modus) {
+            final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("DescriptorString"));
+            t.add(new DefaultMutableTreeNode(new KVP("ISO_639_language_code",ISO_639_language_code,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("number_segments",number_segments,null)));
+            Utils.addListJTree(t,segmentList,modus,"segmentList");
+            return t;
+        }
+
+        public class DescriptorSegment implements TreeNode{
+            private int compression_type;
+            private byte[] mode;
+            private int number_bytes;
+            private byte[] compressed_string_byte;
+
+
+
+            @Override
+            public DefaultMutableTreeNode getJTreeNode(int modus) {
+                final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("DescriptorSegment"));
+                t.add(new DefaultMutableTreeNode(new KVP("compression_type",compression_type,explain_compression_type(compression_type))));
+                t.add(new DefaultMutableTreeNode(new KVP("mode",mode,explain_modes(mode))));
+                t.add(new DefaultMutableTreeNode(new KVP("number_bytes",number_bytes,null)));
+                t.add(new DefaultMutableTreeNode(new KVP("compressed_string_byte",compressed_string_byte,null)));
+                return t;
+            }
+
+            public int getCompression_type() {
+                return compression_type;
+            }
+
+            public void setCompression_type(int compression_type) {
+                this.compression_type = compression_type;
+            }
+
+            public byte[] getMode() {
+                return mode;
+            }
+
+            public void setMode(byte[] mode) {
+                this.mode = mode;
+            }
+
+            public int getNumber_bytes() {
+                return number_bytes;
+            }
+
+            public void setNumber_bytes(int number_bytes) {
+                this.number_bytes = number_bytes;
+            }
+
+            public byte[] getCompressed_string_byte() {
+                return compressed_string_byte;
+            }
+
+            public void setCompressed_string_byte(byte[] compressed_string_byte) {
+                this.compressed_string_byte = compressed_string_byte;
+            }
+        }
+
+        public byte[] getISO_639_language_code() {
+            return ISO_639_language_code;
+        }
+
+        public void setISO_639_language_code(byte[] ISO_639_language_code) {
+            this.ISO_639_language_code = ISO_639_language_code;
+        }
+
+        public int getNumber_segments() {
+            return number_segments;
+        }
+
+        public void setNumber_segments(int number_segments) {
+            this.number_segments = number_segments;
+        }
+
+        public List<DescriptorSegment> getSegmentList() {
+            return segmentList;
+        }
+
+        public void setSegmentList(List<DescriptorSegment> segmentList) {
+            this.segmentList = segmentList;
+        }
+    }
+
+    /**
+     * @param b
+     * @param offset
+     * @param
+     */
+    public MSSdescriptor(byte[] b, int offset) {
+
+        int current_offset = offset;
+        number_strings = Utils.getInt(b,current_offset,1,Utils.MASK_8BITS);
+        current_offset += 1;
+
+        descriptorStringList = new ArrayList<>();
+
+        for (int i = 0; i < number_strings; i++) {
+            DescriptorString descriptorString = new DescriptorString();
+            descriptorString.setISO_639_language_code(Arrays.copyOfRange(b,current_offset,current_offset+3));
+            current_offset += 3;
+            descriptorString.setNumber_segments(Utils.getInt(b,current_offset,1,Utils.MASK_8BITS));
+            current_offset += 1;
+            descriptorString.segmentList = new ArrayList<>();
+            for (int j = 0; j < descriptorString.getNumber_segments(); j++) {
+                DescriptorString.DescriptorSegment descriptorSegment = descriptorString.new DescriptorSegment();
+//                descriptorSegment.setCompression_type(Arrays.copyOfRange(b,current_offset,current_offset + 1));
+                descriptorSegment.setCompression_type(Utils.getInt(b,current_offset,1,Utils.MASK_8BITS));
+                current_offset += 1;
+                descriptorSegment.setMode(Arrays.copyOfRange(b,current_offset,current_offset + 1));
+                current_offset += 1;
+                descriptorSegment.setNumber_bytes(Utils.getInt(b,current_offset,1,Utils.MASK_8BITS));
+                current_offset += 1;
+                descriptorSegment.setCompressed_string_byte(Arrays.copyOfRange
+                        (b,current_offset,current_offset + descriptorSegment.getNumber_bytes()));
+                current_offset += descriptorSegment.getNumber_bytes();
+                descriptorString.segmentList.add(descriptorSegment);
+            }
+            descriptorStringList.add(descriptorString);
+        }
+    }
+
+
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        final DefaultMutableTreeNode t = new DefaultMutableTreeNode("Multiple String Structure");
+        t.add(new DefaultMutableTreeNode(new KVP("number_strings",number_strings,null)));
+        Utils.addListJTree(t,descriptorStringList,modus,"descriptorStringList");
+        return t;
+    }
+
+
+    public String getDescriptorname(){
+        return "Multiple String Structure";
+    }
+
+    public static String explain_compression_type(int compression_type){
+        StringBuilder s = new StringBuilder();
+        if(compression_type == 0){
+            s.append("No compression");
+        }
+        if(compression_type == 1){
+            s.append("Huffman coding");
+        }
+        if(compression_type == 2){
+            s.append("Huffman coding");
+        }
+        if(compression_type >= 3 && compression_type <= 175){
+            s.append("reserved");
+        }
+        if(compression_type >= 176 && compression_type <= 255){
+            s.append("Used in other systems");
+        }
+        return s.toString();
+    }
+
+    public static String explain_modes(byte[] modes){
+        int modes_number = Utils.getInt(modes,0,modes.length,Utils.MASK_8BITS);
+        StringBuilder s = new StringBuilder();
+        switch (modes_number){
+            case 0: return s.append("Select Unicode Code Range 0x0000 – 0x00FF").toString();
+            case 1: return s.append("Select Unicode Code Range 0x0100 – 0x01FF ").toString();
+            case 2: return s.append("Select Unicode Code Range 0x0200 – 0x02FF ").toString();
+            case 3: return s.append("Select Unicode Code Range 0x0300 – 0x03FF ").toString();
+            case 4: return s.append("Select Unicode Code Range 0x0400 – 0x04FF").toString();
+            case 5: return s.append("Select Unicode Code Range 0x0500 – 0x05FF").toString();
+            case 6: return s.append("Select Unicode Code Range 0x0600 – 0x06FF ").toString();
+//            case 7:
+//            case 8: return s.append("Reserved").toString();
+            case 9: return s.append("Select Unicode Code Range 0x0900 – 0x09FF ").toString();
+            case 10: return s.append("Select Unicode Code Range 0x0A00 – 0x0AFF ").toString();
+            case 11: return s.append("Select Unicode Code Range 0x0B00 – 0x0BFF ").toString();
+            case 12: return s.append("Select Unicode Code Range 0x0C00 – 0x0CFF  ").toString();
+            case 13: return s.append("Select Unicode Code Range 0x0D00 – 0x0DFF  ").toString();
+            case 14: return s.append("Select Unicode Code Range 0x0E00 – 0x0EFF").toString();
+            case 15: return s.append("Select Unicode Code Range 0x0F00 – 0x0FFF").toString();
+            case 16: return s.append("Select Unicode Code Range 0x1000 – 0x10FF ").toString();
+
+            case 32: return s.append("Select Unicode Code Range 0x2000 – 0x20FF ").toString();
+            case 33: return s.append("Select Unicode Code Range 0x2100 – 0x21FF ").toString();
+            case 34: return s.append("Select Unicode Code Range 0x2200 – 0x22FF ").toString();
+            case 35: return s.append("Select Unicode Code Range 0x2300 – 0x23FF ").toString();
+            case 36: return s.append("Select Unicode Code Range 0x2400 – 0x24FF  ").toString();
+            case 37: return s.append("Select Unicode Code Range 0x2500 – 0x25FF  ").toString();
+            case 38: return s.append("Select Unicode Code Range 0x2600 – 0x26FF").toString();
+            case 39: return s.append("Select Unicode Code Range 0x2700 – 0x27FF").toString();
+
+            case 48: return s.append("Select Unicode Code Range 0x3000 – 0x30FF  ").toString();
+            case 49: return s.append("Select Unicode Code Range 0x3100 – 0x31FF  ").toString();
+            case 50: return s.append("Select Unicode Code Range 0x3200 – 0x32FF").toString();
+            case 51: return s.append("Select Unicode Code Range 0x3300 – 0x33FF").toString();
+
+            case 62: return s.append("Select Standard Compression Scheme for Unicode (SCSU)").toString();
+            case 63: return s.append("Select Unicode, UTF-16 Form").toString();
+            case 64:
+            case 65: return s.append("Assigned to ATSC standard for Taiwan").toString();
+            case 66:
+            case 67:
+            case 68:
+            case 69:
+            case 70:
+            case 71: return s.append("Reserved for future ATSC use").toString();
+            case 72: return s.append("Assigned to ATSC standard for South Korea").toString();
+
+            case 255: return s.append("Not applicable").toString();
+
+            default: return s.append("Reserved").toString();
+        }
+    }
+
+    public int getNumber_strings() {
+        return number_strings;
+    }
+
+    public void setNumber_strings(int number_strings) {
+        this.number_strings = number_strings;
+    }
+
+    public List<DescriptorString> getDescriptorStringList() {
+        return descriptorStringList;
+    }
+
+    public void setDescriptorStringList(List<DescriptorString> descriptorStringList) {
+        this.descriptorStringList = descriptorStringList;
+    }
+
+    public static String get_multi_string(List<MSSdescriptor> mssList){
+        StringBuilder s = new StringBuilder();
+        try{
+            for (MSSdescriptor msSdescriptor : mssList) {
+                for (MSSdescriptor.DescriptorString string : msSdescriptor.getDescriptorStringList()) {
+                    for (MSSdescriptor.DescriptorString.DescriptorSegment segment : string.getSegmentList()) {
+                        s.append(Utils.hexToAsciiString(segment.getCompressed_string_byte()));
+                    }
+                }
+            }
+        }catch (RuntimeException e){
+            return s.toString();
+        }
+        return s.toString();
+    }
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MultipleStringStructure.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MultipleStringStructure.java
new file mode 100644
index 0000000..b90f162
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/MultipleStringStructure.java
@@ -0,0 +1,158 @@
+package nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.atsc;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.controller.TreeNode;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.psi.TableSection;
+import nl.digitalekabeltelevisie.util.Utils;
+
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class MultipleStringStructure extends Descriptor {
+    private int number_strings;
+
+    private List<DescriptorString> descriptorStringList;
+
+    public class DescriptorString implements TreeNode{
+        private byte[] ISO_639_language_code;
+        private int number_segments;
+        private List<DescriptorSegment> segmentList;
+
+        @Override
+        public DefaultMutableTreeNode getJTreeNode(int modus) {
+            final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("DescriptorString"));
+            t.add(new DefaultMutableTreeNode(new KVP("ISO_639_language_code",ISO_639_language_code,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("number_segments",number_segments,null)));
+            Utils.addListJTree(t,segmentList,modus,"segmentList");
+            return t;
+        }
+
+        public class DescriptorSegment implements TreeNode{
+            private byte[] compression_type;
+            private byte[] mode;
+            private int number_bytes;
+            private byte[] compressed_string_byte;
+
+
+
+            @Override
+            public DefaultMutableTreeNode getJTreeNode(int modus) {
+                final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("DescriptorSegment"));
+                t.add(new DefaultMutableTreeNode(new KVP("compression_type",compression_type,null)));
+                t.add(new DefaultMutableTreeNode(new KVP("mode",mode,null)));
+                t.add(new DefaultMutableTreeNode(new KVP("number_bytes",number_bytes,null)));
+                t.add(new DefaultMutableTreeNode(new KVP("compressed_string_byte",compressed_string_byte,null)));
+                return t;
+            }
+
+            public byte[] getCompression_type() {
+                return compression_type;
+            }
+
+            public void setCompression_type(byte[] compression_type) {
+                this.compression_type = compression_type;
+            }
+
+            public byte[] getMode() {
+                return mode;
+            }
+
+            public void setMode(byte[] mode) {
+                this.mode = mode;
+            }
+
+            public int getNumber_bytes() {
+                return number_bytes;
+            }
+
+            public void setNumber_bytes(int number_bytes) {
+                this.number_bytes = number_bytes;
+            }
+
+            public byte[] getCompressed_string_byte() {
+                return compressed_string_byte;
+            }
+
+            public void setCompressed_string_byte(byte[] compressed_string_byte) {
+                this.compressed_string_byte = compressed_string_byte;
+            }
+        }
+
+        public byte[] getISO_639_language_code() {
+            return ISO_639_language_code;
+        }
+
+        public void setISO_639_language_code(byte[] ISO_639_language_code) {
+            this.ISO_639_language_code = ISO_639_language_code;
+        }
+
+        public int getNumber_segments() {
+            return number_segments;
+        }
+
+        public void setNumber_segments(int number_segments) {
+            this.number_segments = number_segments;
+        }
+
+        public List<DescriptorSegment> getSegmentList() {
+            return segmentList;
+        }
+
+        public void setSegmentList(List<DescriptorSegment> segmentList) {
+            this.segmentList = segmentList;
+        }
+    }
+
+    /**
+     * @param b
+     * @param offset
+     * @param parent
+     */
+    public MultipleStringStructure(byte[] b, int offset, TableSection parent) {
+        super(b, offset, parent);
+        int current_offset = offset;
+        number_strings = Utils.getInt(b,current_offset,1,Utils.MASK_8BITS);
+        current_offset += 1;
+
+        descriptorStringList = new ArrayList<>();
+
+        for (int i = 0; i < number_strings; i++) {
+            DescriptorString descriptorString = new DescriptorString();
+            descriptorString.setISO_639_language_code(Arrays.copyOfRange(b,current_offset,current_offset+3));
+            current_offset += 3;
+            descriptorString.setNumber_segments(Utils.getInt(b,current_offset,1,Utils.MASK_8BITS));
+            current_offset += 1;
+            descriptorString.segmentList = new ArrayList<>();
+            for (int j = 0; j < descriptorString.getNumber_segments(); j++) {
+                DescriptorString.DescriptorSegment descriptorSegment = descriptorString.new DescriptorSegment();
+                descriptorSegment.setCompression_type(Arrays.copyOfRange(b,current_offset,current_offset + 1));
+                current_offset += 1;
+                descriptorSegment.setMode(Arrays.copyOfRange(b,current_offset,current_offset + 1));
+                current_offset += 1;
+                descriptorSegment.setNumber_bytes(Utils.getInt(b,current_offset,1,Utils.MASK_8BITS));
+                current_offset += 1;
+                descriptorSegment.setCompressed_string_byte(Arrays.copyOfRange
+                        (b,current_offset,current_offset + descriptorSegment.getNumber_bytes()));
+                current_offset += descriptorSegment.getNumber_bytes();
+                descriptorString.segmentList.add(descriptorSegment);
+            }
+            descriptorStringList.add(descriptorString);
+        }
+    }
+
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        final DefaultMutableTreeNode t = super.getJTreeNode(modus);
+        t.add(new DefaultMutableTreeNode(new KVP("number_strings",number_strings,null)));
+        Utils.addListJTree(t,descriptorStringList,modus,"descriptorStringList");
+        return t;
+    }
+
+    @Override
+    public String getDescriptorname(){
+        return "Multiple String Structure";
+    }
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/RedistributionControlDescriptor.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/RedistributionControlDescriptor.java
new file mode 100644
index 0000000..b330ce8
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/RedistributionControlDescriptor.java
@@ -0,0 +1,63 @@
+package nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.atsc;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.controller.TreeNode;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.psi.TableSection;
+import nl.digitalekabeltelevisie.util.Utils;
+
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class RedistributionControlDescriptor extends Descriptor {
+    private List<RC_information> rc_informationList;
+    /**
+     * @param b
+     * @param offset
+     * @param parent
+     */
+    public RedistributionControlDescriptor(byte[] b, int offset, TableSection parent) {
+        super(b, offset, parent);
+        offset += 2;
+        rc_informationList = new ArrayList<>();
+        for (int i = 0; i < getDescriptorLength(); i++) {
+            RC_information rc_information = new RC_information();
+            rc_information.setRc_information(Utils.getInt(b,offset,1,Utils.MASK_8BITS));
+            offset += 1;
+        }
+    }
+
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        final DefaultMutableTreeNode t = super.getJTreeNode(modus);
+        Utils.addListJTree(t,rc_informationList,modus,"rc_informationList");
+        return t;
+    }
+
+    @Override
+    public String getDescriptorname(){
+        return "Redistribution Control Descriptor ";
+    }
+
+
+    public class RC_information implements TreeNode{
+        private int rc_information;
+
+        @Override
+        public DefaultMutableTreeNode getJTreeNode(int modus) {
+            final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("RC_information"));
+            t.add(new DefaultMutableTreeNode(new KVP("rc_information",rc_information,null)));
+            return t;
+        }
+
+        public int getRc_information() {
+            return rc_information;
+        }
+
+        public void setRc_information(int rc_information) {
+            this.rc_information = rc_information;
+        }
+    }
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ServiceLocationDescriptor.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ServiceLocationDescriptor.java
new file mode 100644
index 0000000..21e7820
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/ServiceLocationDescriptor.java
@@ -0,0 +1,114 @@
+package nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.atsc;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.controller.TreeNode;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.psi.TableSection;
+import nl.digitalekabeltelevisie.util.Utils;
+
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class ServiceLocationDescriptor extends Descriptor {
+    private int PCR_PID;
+    private int number_elements;
+    private List<ElementaryStream> elementaryStreamList;
+
+    public class ElementaryStream implements TreeNode {
+        private int stream_type;
+        private int elementary_PID;
+        private byte[] ISO_639_language_code;
+
+        @Override
+        public DefaultMutableTreeNode getJTreeNode(int modus) {
+            final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("ElementaryStream"));
+            t.add(new DefaultMutableTreeNode(new KVP("stream_type",stream_type,explain_stream_type(stream_type))));
+            t.add(new DefaultMutableTreeNode(new KVP("elementary_PID",elementary_PID,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("ISO_639_language_code",ISO_639_language_code,null)));
+            return t;
+        }
+
+        public int getStream_type() {
+            return stream_type;
+        }
+
+        public void setStream_type(int stream_type) {
+            this.stream_type = stream_type;
+        }
+
+        public int getElementary_PID() {
+            return elementary_PID;
+        }
+
+        public void setElementary_PID(int elementary_PID) {
+            this.elementary_PID = elementary_PID;
+        }
+
+        public byte[] getISO_639_language_code() {
+            return ISO_639_language_code;
+        }
+
+        public void setISO_639_language_code(byte[] ISO_639_language_code) {
+            this.ISO_639_language_code = ISO_639_language_code;
+        }
+
+    }
+
+    /**
+     * @param b
+     * @param offset
+     * @param parent
+     */
+    public ServiceLocationDescriptor(byte[] b, int offset, TableSection parent) {
+        super(b, offset, parent);
+        int current_offset = offset+2;
+        PCR_PID = Utils.getInt(b,current_offset,2,Utils.MASK_13BITS);
+        current_offset += 2;
+        number_elements = Utils.getInt(b,current_offset,1,Utils.MASK_8BITS);
+        current_offset += 1;
+        elementaryStreamList = new ArrayList<>();
+        for (int i = 0; i < number_elements; i++) {
+            ElementaryStream stream = new ElementaryStream();
+            stream.setStream_type(Utils.getInt(b,current_offset,1,Utils.MASK_8BITS));
+            current_offset += 1;
+            stream.setElementary_PID(Utils.getInt(b,current_offset,2,Utils.MASK_13BITS));
+            current_offset += 2;
+            stream.setISO_639_language_code(Arrays.copyOfRange(b,current_offset,current_offset+3));
+            current_offset += 3;
+            elementaryStreamList.add(stream);
+        }
+    }
+
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        final DefaultMutableTreeNode t = super.getJTreeNode(modus);
+        t.add(new DefaultMutableTreeNode(new KVP("PCR_PID",PCR_PID,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("number_elements",number_elements,null)));
+        Utils.addListJTree(t,elementaryStreamList,modus,"elementaryStreamList");
+        return t;
+    }
+
+    @Override
+    public String getDescriptorname(){
+        return "Service_Location_Descriptor";
+    }
+
+    public static String explain_stream_type(int stream_type){
+        StringBuilder s = new StringBuilder();
+        switch (stream_type){
+            case 2:return s.append("ITU-T Rec. H.262 | ISO/IEC 13818-2 Video or ISO/IEC 11172-2 " +
+                    "constrained parameter video stream").toString();
+            case 6:return s.append("PES packets containing A/90 streaming, synchronized data").toString();
+            case 11:return s.append("DSM-CC sections containing A/90 asynchronous data").toString();
+            case 13:return s.append("DSM-CC addressable sections per A/90").toString();
+            case 20:return s.append("DSM-CC sections containing non-streaming, synchronized data per A/90").toString();
+            case 129:return s.append("Audio per ATSC A/53 Part 5").toString();
+            case 149:return s.append("Sections conveying A/90 Data Service Table, Network Resources Table").toString();
+            case 194:return s.append("PES packets containing A/90 streaming, synchronous data").toString();
+
+            default:return null;
+        }
+    }
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/TimeShiftedServiceDescriptor.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/TimeShiftedServiceDescriptor.java
new file mode 100644
index 0000000..e17d29b
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/descriptors/extension/atsc/TimeShiftedServiceDescriptor.java
@@ -0,0 +1,72 @@
+package nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.atsc;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.controller.TreeNode;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.psi.TableSection;
+import nl.digitalekabeltelevisie.util.Utils;
+
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class TimeShiftedServiceDescriptor extends Descriptor {
+    private int number_of_services;
+    private List<TimeShiftedService> timeShiftedServiceList;
+
+    /**
+     * @param b
+     * @param offset
+     * @param parent
+     */
+    public TimeShiftedServiceDescriptor(byte[] b, int offset, TableSection parent) {
+        super(b, offset, parent);
+        offset += 2;
+        number_of_services = Utils.getInt(b,offset,1,Utils.MASK_5BITS);
+        offset += 1;
+
+        timeShiftedServiceList = new ArrayList<>();
+        for (int i = 0; i < number_of_services; i++) {
+            TimeShiftedService timeShiftedService = new TimeShiftedService();
+            timeShiftedService.time_shift = Utils.getInt(b,offset,2,Utils.MASK_10BITS);
+
+            byte[] temp = Arrays.copyOfRange(b,offset,offset+3);
+            timeShiftedService.major_channel_number = Utils.getBitsFromByteArray(temp,4,10);
+            timeShiftedService.minor_channel_number = Utils.getBitsFromByteArray(temp,14,10);
+            offset += 3;
+        }
+    }
+
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        final DefaultMutableTreeNode t =  super.getJTreeNode(modus);
+        t.add(new DefaultMutableTreeNode(new KVP("number_of_services",number_of_services,null)));
+        Utils.addListJTree(t,timeShiftedServiceList,modus,"timeShiftedServiceList");
+        return t;
+    }
+
+    @Override
+    public String getDescriptorname(){
+        return "Time Shifted Service Descriptor";
+    }
+
+    public class TimeShiftedService implements TreeNode {
+        private int time_shift;
+        private int major_channel_number;
+        private int minor_channel_number;
+
+        @Override
+        public DefaultMutableTreeNode getJTreeNode(int modus) {
+            final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("TimeShiftedService"));
+            t.add(new DefaultMutableTreeNode(new KVP("time_shift",time_shift,explain_time_shift())));
+            t.add(new DefaultMutableTreeNode(new KVP("major_channel_number",major_channel_number,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("minor_channel_number",minor_channel_number,null)));
+            return t;
+        }
+    }
+
+    public static String explain_time_shift(){
+        return " the number of minutes time-shifted";
+    }
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/CVCT.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/CVCT.java
new file mode 100644
index 0000000..93fa32a
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/CVCT.java
@@ -0,0 +1,73 @@
+package nl.digitalekabeltelevisie.data.mpeg.psi;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.data.mpeg.PSI;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.LocalTimeOffsetDescriptor;
+import nl.digitalekabeltelevisie.util.tablemodel.FlexTableModel;
+import nl.digitalekabeltelevisie.util.tablemodel.TableHeader;
+import nl.digitalekabeltelevisie.util.tablemodel.TableHeaderBuilder;
+
+import javax.swing.table.TableModel;
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.util.ArrayList;
+import java.util.List;
+
+import static nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor.findGenericDescriptorsInList;
+
+// author : dinghang.men
+
+public class CVCT extends AbstractPSITabel{
+
+    private final List<CVCTsection> cvctSectionList = new ArrayList<>();
+
+    public CVCT(final PSI parentPSI){
+        super(parentPSI);
+    }
+
+    public void update(final CVCTsection section){
+        if(!cvctSectionList.contains(section)){
+            cvctSectionList.add(section);
+        }
+    }
+
+    static TableHeader<CVCTsection, LocalTimeOffsetDescriptor> buildCVCTTableHeader() {
+        return new TableHeaderBuilder<CVCTsection,LocalTimeOffsetDescriptor>()
+                .addRequiredBaseColumn("Protocol_version",CVCTsection::getProtocol_version,Integer.class)
+                .addRequiredBaseColumn("Num_channels_in_section",CVCTsection::getNum_channels_in_section,Integer.class)
+                .addRequiredBaseColumn("VirtualChannelList",CVCTsection::getVirtualChannelList, List.class)
+                .addRequiredBaseColumn("Additional_descriptors_length",CVCTsection::getAdditional_descriptors_length,Integer.class)
+                .addRequiredBaseColumn("VirtualChannelList",CVCTsection::getAdditional_descriptorList, List.class)
+                .build();
+    }
+
+
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        KVP kvp = new KVP("CVCT");
+        if(!cvctSectionList.isEmpty()){
+            //设置Table格式
+            kvp.setTableSource(this::getTableModel);
+        }
+        final DefaultMutableTreeNode t = new DefaultMutableTreeNode(kvp);
+        //将sttSectionList中的所有数据都添加到树节点中
+        for(CVCTsection item : cvctSectionList){
+            t.add(item.getJTreeNode(modus));
+        }
+        return t;
+    }
+
+    public TableModel getTableModel(){
+        //创建表模型
+        FlexTableModel<CVCTsection, LocalTimeOffsetDescriptor> tableModel = new FlexTableModel<>(buildCVCTTableHeader());
+        //将sttSectionList的数据添加到表模型中
+        for (CVCTsection item : cvctSectionList) {
+            if(item != null) {
+                tableModel.addData(item, findGenericDescriptorsInList(item.getAdditional_descriptorList(),LocalTimeOffsetDescriptor.class));
+            }
+        }
+        //模型处理
+        tableModel.process();
+        return tableModel;
+    }
+
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/CVCTsection.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/CVCTsection.java
new file mode 100644
index 0000000..62a08aa
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/CVCTsection.java
@@ -0,0 +1,489 @@
+package nl.digitalekabeltelevisie.data.mpeg.psi;
+
+import com.sun.source.tree.Tree;
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.controller.TreeNode;
+import nl.digitalekabeltelevisie.data.mpeg.PID;
+import nl.digitalekabeltelevisie.data.mpeg.PsiSectionData;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.DescriptorFactory;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.LocalTimeOffsetDescriptor;
+import nl.digitalekabeltelevisie.util.Utils;
+import nl.digitalekabeltelevisie.util.tablemodel.FlexTableModel;
+
+import javax.swing.table.TableModel;
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.math.BigInteger;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static java.util.Arrays.copyOfRange;
+import static nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor.findGenericDescriptorsInList;
+
+public class CVCTsection extends TableSection{
+    private int protocol_version;
+    //An 8-bit unsigned integer field,the only valid value for protocol_version is zero.
+
+    private int num_channels_in_section;
+    //This 8 bit field specifies the number of virtual channels in this VCT
+    //section. The number is limited by the section length.
+    //这个8位字段指定了这个VCT段中的虚拟通道的数量。数量受部分长度的限制。
+
+    private List<VirtualChannel> VirtualChannelList;
+
+    public class VirtualChannel implements TreeNode{
+        private  byte[] short_name;
+        //The name of the virtual channel, represented as a sequence of one to seven 16-bit
+        //code values interpreted in accordance with the UTF-16 representation of Unicode character
+        //data. If the length of the name requires fewer than seven 16-bit code values, this field shall be
+        //padded out to seven 16-bit code values using the Unicode NUL character (0x0000)
+        //虚拟通道的名称，表示为1到7个16位代码值的序列，这些代码值按照Unicode字符数据的UTF-16表示进行解释。
+        // 如果名称的长度需要少于7个16位代码值，则该字段将使用Unicode NUL字符(0x0000)填充为7个16位代码值。
+
+        private int major_channel_number;
+        //10bits
+
+        private  int minor_channel_number;
+        //10bits
+
+        private  int modulation_mode;
+        //8bits
+
+        private  BigInteger carrier_frequency;
+        //32bits
+
+        private  int channel_TSID;
+        //16bits
+
+        private  int program_number;
+        //16bits
+
+        private  int ETM_location;
+        //2bits
+
+        private  int access_controlled;
+        //1bits
+
+        private  int hidden;
+        //1bit
+
+        private  int hide_guide;
+        //1bits
+
+        private  int service_type;
+        //6bits
+
+        private  int source_id;
+        //16bit
+
+        private int descriptors_length;
+        //10bits
+
+        private  List<Descriptor> descriptorList;
+
+
+        @Override
+        public DefaultMutableTreeNode getJTreeNode(int modus) {
+            final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("virtual_channel"));
+            t.add(new DefaultMutableTreeNode(new KVP("short_name",short_name,explain_short_name(short_name))));
+            t.add(new DefaultMutableTreeNode(new KVP("major_channel_number",major_channel_number,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("minor_channel_number",minor_channel_number,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("modulation_mode",modulation_mode,explain_modulation_mode(modulation_mode))));
+            t.add(new DefaultMutableTreeNode(new KVP("carrier_frequency",carrier_frequency,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("channel_TSID",channel_TSID,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("program_number",program_number,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("ETM_location",ETM_location,explain_ETM_location(ETM_location))));
+            t.add(new DefaultMutableTreeNode(new KVP("access_controlled",access_controlled,explain_access_controlled(access_controlled))));
+            t.add(new DefaultMutableTreeNode(new KVP("hidden",hidden,explain_hidden(hidden))));
+            t.add(new DefaultMutableTreeNode(new KVP("hide_guide",hide_guide,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("service_type",service_type,explain_service_type(service_type))));
+            t.add(new DefaultMutableTreeNode(new KVP("source_id",source_id,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("descriptors_length",descriptors_length,null)));
+            Utils.addListJTree(t,descriptorList,modus,"VirtualChannel descriptors");
+            return t;
+        }
+
+        public byte[] getShort_name() {
+            return short_name;
+        }
+
+        public void setShort_name(byte[] short_name) {
+            this.short_name = short_name;
+        }
+
+        public int getMajor_channel_number() {
+            return major_channel_number;
+        }
+
+        public void setMajor_channel_number(int major_channel_number) {
+            this.major_channel_number = major_channel_number;
+        }
+
+        public int getMinor_channel_number() {
+            return minor_channel_number;
+        }
+
+        public void setMinor_channel_number(int minor_channel_number) {
+            this.minor_channel_number = minor_channel_number;
+        }
+
+        public int getModulation_mode() {
+            return modulation_mode;
+        }
+
+        public void setModulation_mode(int modulation_mode) {
+            this.modulation_mode = modulation_mode;
+        }
+
+        public BigInteger getCarrier_frequency() {
+            return carrier_frequency;
+        }
+
+        public void setCarrier_frequency(BigInteger carrier_frequency) {
+            this.carrier_frequency = carrier_frequency;
+        }
+
+        public int getChannel_TSID() {
+            return channel_TSID;
+        }
+
+        public void setChannel_TSID(int channel_TSID) {
+            this.channel_TSID = channel_TSID;
+        }
+
+        public int getProgram_number() {
+            return program_number;
+        }
+
+        public void setProgram_number(int program_number) {
+            this.program_number = program_number;
+        }
+
+        public int getETM_location() {
+            return ETM_location;
+        }
+
+        public void setETM_location(int ETM_location) {
+            this.ETM_location = ETM_location;
+        }
+
+        public int getAccess_controlled() {
+            return access_controlled;
+        }
+
+        public void setAccess_controlled(int access_controlled) {
+            this.access_controlled = access_controlled;
+        }
+
+        public int getHidden() {
+            return hidden;
+        }
+
+        public void setHidden(int hidden) {
+            this.hidden = hidden;
+        }
+
+        public int getHide_guide() {
+            return hide_guide;
+        }
+
+        public void setHide_guide(int hide_guide) {
+            this.hide_guide = hide_guide;
+        }
+
+        public int getService_type() {
+            return service_type;
+        }
+
+        public void setService_type(int service_type) {
+            this.service_type = service_type;
+        }
+
+        public int getSource_id() {
+            return source_id;
+        }
+
+        public void setSource_id(int source_id) {
+            this.source_id = source_id;
+        }
+
+        public int getDescriptors_length() {
+            return descriptors_length;
+        }
+
+        public void setDescriptors_length(int descriptors_length) {
+            this.descriptors_length = descriptors_length;
+        }
+
+        public List<Descriptor> getDescriptorList() {
+            return descriptorList;
+        }
+
+        public void setDescriptorList(List<Descriptor> descriptorList) {
+            this.descriptorList = descriptorList;
+        }
+    }
+
+    private int additional_descriptors_length;
+
+    private  List<Descriptor> additional_descriptorList;
+
+    public int getProtocol_version() {
+        return protocol_version;
+    }
+
+    public void setProtocol_version(int protocol_version) {
+        this.protocol_version = protocol_version;
+    }
+
+    public int getNum_channels_in_section() {
+        return num_channels_in_section;
+    }
+
+    public void setNum_channels_in_section(int num_channels_in_section) {
+        this.num_channels_in_section = num_channels_in_section;
+    }
+
+    public List<VirtualChannel> getVirtualChannelList() {
+        return VirtualChannelList;
+    }
+
+    public void setVirtualChannelList(List<VirtualChannel> virtualChannelList) {
+        VirtualChannelList = virtualChannelList;
+    }
+
+    public int getAdditional_descriptors_length() {
+        return additional_descriptors_length;
+    }
+
+    public void setAdditional_descriptors_length(int additional_descriptors_length) {
+        this.additional_descriptors_length = additional_descriptors_length;
+    }
+
+    public List<Descriptor> getAdditional_descriptorList() {
+        return additional_descriptorList;
+    }
+
+    public void setAdditional_descriptorList(List<Descriptor> additional_descriptorList) {
+        this.additional_descriptorList = additional_descriptorList;
+    }
+
+
+    public CVCTsection(final PsiSectionData raw_data, final PID parent){
+        super(raw_data, parent);
+        protocol_version = Utils.getInt(raw_data.getData(),8,1,Utils.MASK_8BITS);
+
+        num_channels_in_section = Utils.getInt(raw_data.getData(),9,1,Utils.MASK_8BITS);
+
+
+        int offset = 10;
+
+        //VirtualChannelList = bulidVirtualChannelList(raw_data.getData(), offset ,num_channels_in_section);
+
+        VirtualChannelList = new ArrayList<>();
+
+        //final ArrayList<VirtualChannel> r = new ArrayList<>();
+
+        for (int i = 0; i < num_channels_in_section; i++) {
+            VirtualChannel vc = new VirtualChannel();
+            vc.setShort_name(copyOfRange(raw_data.getData(),offset,offset+14));
+            offset += 14;
+
+            byte[]  temp = copyOfRange(raw_data.getData(),offset,offset+3);
+            //vc.setMajor_channel_number(Utils.getInt(raw_data.getData(),offset,3, 0x003FF0));//24位中的5-14位
+            vc.setMajor_channel_number(Utils.getBitsFromByteArray(temp,4,10));
+            //vc.setMinor_channel_number(Utils.getInt(raw_data.getData(),offset,3,0xFFC000));//24位中的15-24位
+            vc.setMinor_channel_number(Utils.getBitsFromByteArray(temp,14,10));
+
+            offset += 3;
+            vc.setModulation_mode(Utils.getInt(raw_data.getData(),offset,1,Utils.MASK_8BITS));
+            offset += 1;
+            vc.setCarrier_frequency(Utils.getBigInteger(raw_data.getData(),offset,4));
+            offset += 4;
+            vc.setChannel_TSID(Utils.getInt(raw_data.getData(),offset,2,Utils.MASK_16BITS));
+            offset += 2;
+            vc.setProgram_number(Utils.getInt(raw_data.getData(),offset,2,Utils.MASK_16BITS));
+            offset += 2;
+            //byte temp_8bits = Utils.getBytes(raw_data,offset,1)[0];
+            vc.setETM_location(Utils.getInt(raw_data.getData(),offset,1,Utils.MASK_2BITS));
+
+            //vc.setAccess_controlled(Utils.getInt(raw_data.getData(),offset,1,0x04));
+            byte b = copyOfRange(raw_data.getData(),offset,offset+1)[0];
+
+            vc.setAccess_controlled(Utils.getBit(b,3));
+
+            //vc.setHidden(Utils.getInt(raw_data.getData(),offset,1,0x08));
+            if(Utils.getBit(b,4) != 0){
+                vc.setHidden(1);
+            }else{
+                vc.setHidden(0);
+            }
+            //vc.setHidden(Utils.getBit(b,4));
+
+            //vc.setHide_guide(Utils.getInt(raw_data.getData(),offset,1,0x40));
+            vc.setHide_guide(Utils.getBit(b,7));
+
+            offset += 1;
+            vc.setService_type((Utils.getInt(raw_data.getData(),offset,1,Utils.MASK_6BITS)));
+            offset += 1;
+            vc.setSource_id(Utils.getInt(raw_data.getData(),offset,2,Utils.MASK_16BITS));
+            offset += 2;
+            vc.setDescriptors_length(Utils.getInt(raw_data.getData(),offset,2,Utils.MASK_10BITS));
+            offset += 2;
+            vc.setDescriptorList(DescriptorFactory.buildDescriptorList(raw_data.getData(),offset,vc.getDescriptors_length(),this));
+            VirtualChannelList.add(vc);
+            offset += vc.descriptors_length;
+        }
+
+        additional_descriptors_length = Utils.getInt(raw_data.getData(),offset,2,Utils.MASK_10BITS);
+        additional_descriptorList = DescriptorFactory.buildDescriptorList(raw_data.getData(),offset,additional_descriptors_length,this);
+    }
+
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        final DefaultMutableTreeNode t = super.getJTreeNode(modus);
+        ((KVP) t.getUserObject()).setTableSource(this::getTableModel);
+        t.add(new DefaultMutableTreeNode(new KVP("protocol_version",protocol_version,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("num_channels_in_section",num_channels_in_section,null)));
+        Utils.addListJTree(t,VirtualChannelList,modus,"VirtualChannelList");
+        t.add(new DefaultMutableTreeNode(new KVP("additional_descriptors_length",additional_descriptors_length,null)));
+        Utils.addListJTree(t,additional_descriptorList,modus,"additional_descriptorList");
+        return t;
+    }
+
+    public TableModel getTableModel() {
+        FlexTableModel<CVCTsection, LocalTimeOffsetDescriptor> tableModel =  new FlexTableModel<>(CVCT.buildCVCTTableHeader());
+
+        tableModel.addData(this,findGenericDescriptorsInList(getAdditional_descriptorList(), LocalTimeOffsetDescriptor.class));
+        tableModel.process();
+        return tableModel;
+    }
+
+
+    public static String explain_short_name(byte[] short_name){
+        Charset utf16 = Charset.forName("UTF-16");
+
+        ByteBuffer byteBuffer = ByteBuffer.wrap(short_name);
+        CharBuffer charBuffer = utf16.decode(byteBuffer);
+
+        String decodedString = charBuffer.toString();
+//        StringBuilder s = new StringBuilder();
+//        s.append("Decoded String: ");
+        return decodedString;
+    }
+
+    public static String explain_modulation_mode(int modulation_mode){
+        StringBuilder s = new StringBuilder();
+        if(modulation_mode == 0){
+            s.append("Reserved");
+        }
+        if(modulation_mode == 1){
+            s.append("Analog");
+        }
+        if(modulation_mode == 2){
+            s.append("SCTE_mode_1, 5.057 Msps, 64-QAM");
+        }
+        if(modulation_mode == 3){
+            s.append("SCTE_mode_2, 5.361 Msps, 256-QAM");
+        }
+        if(modulation_mode == 4){
+            s.append("ATSC (8 VSB)");
+        }
+        if(modulation_mode == 5){
+            s.append("ATSC (16 VSB)");
+        }
+        if(modulation_mode >= 6 && modulation_mode <= 127){
+            s.append("Reserved for future use by ATSC");
+        }
+        if(modulation_mode >= 128 && modulation_mode <= 255){
+            s.append("User Private");
+        }
+        return s.toString();
+    }
+
+    public static String explain_ETM_location(int ETM_location){
+        StringBuilder s = new StringBuilder();
+        if(ETM_location == 0){
+            s.append("No ETM");
+        }
+        if(ETM_location == 1){
+            s.append("ETM located in the PTC carrying this PSIP");
+        }
+        if(ETM_location == 2){
+            s.append("ETM located in the PTC specified by the \n" +
+                    "channel_TSID");
+        }
+        if(ETM_location == 3){
+            s.append("[Reserved for future ATSC use]");
+        }
+        return s.toString();
+    }
+
+    public static String explain_access_controlled(int access_controlled){
+        StringBuilder s = new StringBuilder();
+        if(access_controlled == 0){
+            s.append("events associated with \n" +
+                    "this virtual channel may be access controlled");
+        }
+        if(access_controlled == 1){
+            s.append("event access is not \n" +
+                    "restricted");
+        }
+        return s.toString();
+    }
+
+    public static String explain_hidden(int hidden){
+        StringBuilder s = new StringBuilder();
+        if(hidden == 1){
+            s.append(" the virtual channel is not accessed by \n" +
+                    "the user by direct entry of the virtual channel number.");
+        }else{
+            s.append(" the virtual channel is accessed by \n" +
+                    "the user by direct entry of the virtual channel number.");
+        }
+        return s.toString();
+    }
+
+    public static String explain_hide_guide(int hide_guide){
+        StringBuilder s = new StringBuilder();
+        if(hide_guide == 0){
+            s.append("the virtual channel and its events may appear in EPG displays.");
+        }else{
+            s.append(" test signals and services accessible \n" +
+                    "through application-level pointers.");
+        }
+        return s.toString();
+    }
+
+    public static String explain_service_type(int service_type){
+
+        StringBuilder s = new StringBuilder();
+        if(service_type == 0){
+            s.append("Reserved");
+        }
+        if(service_type == 1){
+            s.append("Analog Television ");
+        }
+        if(service_type == 2){
+            s.append("ATSC Digital Television ");
+        }
+        if(service_type == 3){
+            s.append("ATSC Audio ");
+        }
+        if(service_type == 4){
+            s.append("ATSC Data Only Service ");
+        }
+        if(service_type == 5){
+            s.append("ATSC Software Download Service ");
+        }
+        if(service_type >= 6 && service_type <= 63){
+            s.append("Reserved");
+        }
+        return s.toString();
+    }
+
+
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/EITATSC.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/EITATSC.java
new file mode 100644
index 0000000..a4690b2
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/EITATSC.java
@@ -0,0 +1,337 @@
+package nl.digitalekabeltelevisie.data.mpeg.psi;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.data.mpeg.PSI;
+import nl.digitalekabeltelevisie.data.mpeg.psi.EITsectionATSC.Event;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.util.ServiceIdentification;
+import nl.digitalekabeltelevisie.util.tablemodel.FlexTableModel;
+import nl.digitalekabeltelevisie.util.tablemodel.TableHeader;
+import nl.digitalekabeltelevisie.util.tablemodel.TableHeaderBuilder;
+
+import org.apache.commons.lang3.ArrayUtils;
+
+import javax.swing.table.TableModel;
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.math.BigInteger;
+import java.util.*;
+
+import static nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor.findGenericDescriptorsInList;
+import static nl.digitalekabeltelevisie.util.Utils.addListJTree;
+import static nl.digitalekabeltelevisie.util.Utils.simpleModus;
+
+public class EITATSC extends AbstractPSITabel{
+    private List<EITsectionATSC> eiTsectionATSCList = new ArrayList<>();
+
+    //<source_id,>
+    private final TreeMap<Integer, EITsectionATSC[]> newEit = new TreeMap<>();
+
+    private final TreeMap<Integer, List<EITsectionATSC>> int_list = new TreeMap<>();
+    private BigInteger offset;
+
+    public EITATSC(PSI parentPSI) {
+        super(parentPSI);
+    }
+
+    public void update(final EITsectionATSC section){
+        if(!eiTsectionATSCList.contains(section)){
+
+            eiTsectionATSCList.add(section);
+        }
+    }
+
+    public void update_eit(final EITsectionATSC section){
+        final int source_id = section.getTableIdExtension();
+
+        EITsectionATSC[] eitSections = newEit.computeIfAbsent(source_id, k -> new EITsectionATSC[section.getSectionLastNumber()+1]);
+
+        if(eitSections.length <= section.getSectionNumber()){
+            eitSections = Arrays.copyOf(eitSections,section.getSectionNumber()+1);
+            newEit.put(source_id,eitSections);
+        }
+
+        if(eitSections[section.getSectionNumber()] == null){
+            eitSections[section.getSectionNumber()] = section;
+        }else{
+            final TableSection last = eitSections[section.getSectionNumber()];
+            updateSectionVersion(section, last);
+        }
+    }
+
+    public void update_epg(final EITsectionATSC section){
+        final int source_id = section.getTableIdExtension();
+
+        List<EITsectionATSC> list = int_list.computeIfAbsent(source_id, k -> new ArrayList<>());
+        if(!list.contains(section)){
+            list.add(section);
+        }
+
+    }
+
+
+
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        KVP kvp = new KVP("EITATSC");
+        if(!eiTsectionATSCList.isEmpty()){
+            kvp.setTableSource(this::getTableModel);
+        }
+        final DefaultMutableTreeNode t = new DefaultMutableTreeNode(kvp);
+        for (EITsectionATSC item : eiTsectionATSCList) {
+            t.add(item.getJTreeNode(modus));
+        }
+        return t;
+    }
+
+    public DefaultMutableTreeNode getJTreeNode_eit(int modus) {
+        final KVP eitKVP = new KVP("EITATSC");
+        final DefaultMutableTreeNode t = new DefaultMutableTreeNode(eitKVP);
+
+
+        for(Map.Entry<Integer, EITsectionATSC[]> entry : newEit.entrySet()){
+            Integer source_id = entry.getKey();
+            EITsectionATSC[] sections = entry.getValue();
+            final KVP tableNodeKVP = new KVP("source_id",source_id,null);
+            final DefaultMutableTreeNode tableNode = new DefaultMutableTreeNode(tableNodeKVP);
+            for (EITsectionATSC section : sections) {
+                if(section!= null){
+                    if(!simpleModus(modus)){
+                        addSectionVersionsToJTree(tableNode, section, modus);
+                    }else{
+                        addListJTree(tableNode,section.getEventList(),modus,"events");
+                    }
+                }
+            }
+            t.add(tableNode);
+
+//            final KVP tableNodeKVP = new KVP("source_id",source_id,null);
+//            tableNodeKVP.addTableSource(()->getTableModel_eit(value), "Events");
+//            final DefaultMutableTreeNode tableNode = new DefaultMutableTreeNode(tableNodeKVP);
+//            eitKVP.addTableSource(() ->getTableModel_eit(value),source_id.toString());
+
+        }
+
+        return t;
+    }
+
+    public DefaultMutableTreeNode getJTreeNode_epg(int modus) {
+        final KVP eitKVP = new KVP("EIT_ATSC");
+        final DefaultMutableTreeNode t = new DefaultMutableTreeNode(eitKVP);
+        for(Map.Entry<Integer, List<EITsectionATSC>> entry : int_list.entrySet()){
+            Integer source_id = entry.getKey();
+            List<EITsectionATSC> sections = entry.getValue();
+            final KVP tableNodeKVP = new KVP("source_id",source_id,null);
+            final DefaultMutableTreeNode tableNode = new DefaultMutableTreeNode(tableNodeKVP);
+            for (EITsectionATSC section : sections) {
+                if(section!= null){
+                    if(!simpleModus(modus)){
+                        addSectionVersionsToJTree(tableNode, section, modus);
+                    }else{
+                        addListJTree(tableNode,section.getEventList(),modus,"events");
+                    }
+                }
+            }
+            t.add(tableNode);
+        }
+        return t;
+    }
+
+    static TableHeader<EITsectionATSC, EITsectionATSC.Event> buildEITATSCTableHeader() {
+        return new TableHeaderBuilder<EITsectionATSC,EITsectionATSC.Event>()
+                .addRequiredBaseColumn("source_id",EITsectionATSC::getTableIdExtension,Integer.class)
+                .addOptionalRowColumn("Event_id",Event::getEvent_id,Integer.class)
+                .addOptionalRowColumn("Start_time",Event::getStart_time,Integer.class)
+                .addOptionalRowColumn("Length_in_seconds",Event::getLength_in_seconds, Integer.class)
+                .build();
+    }
+
+    public TableModel getTableModel(){
+        //创建表模型
+        FlexTableModel<EITsectionATSC,EITsectionATSC.Event> tableModel = new FlexTableModel<>(buildEITATSCTableHeader());
+//        for (EITsectionATSC item : eiTsectionATSCList) {
+//            if(item != null){
+//                tableModel.addData(item,item.getEventList());
+//
+//            }
+//        }
+        for(Map.Entry<Integer, List<EITsectionATSC>> entry : int_list.entrySet()) {
+            Integer source_id = entry.getKey();
+            List<EITsectionATSC> sections = entry.getValue();
+            for (EITsectionATSC item : sections) {
+                if(item != null){
+                    tableModel.addData(item,item.getEventList());
+                }
+            }
+        }
+        tableModel.process();
+        return tableModel;
+    }
+
+    public TableModel getTableModel_eit(EITsectionATSC[] sections){
+        //创建表模型
+        FlexTableModel<EITsectionATSC,EITsectionATSC.Event> tableModel = new FlexTableModel<>(buildEITATSCTableHeader());
+        for (EITsectionATSC item : sections) {
+            if(item != null){
+                tableModel.addData(item,item.getEventList());
+
+            }
+        }
+        tableModel.process();
+        return tableModel;
+    }
+
+    public TreeMap<Integer,List<EITsectionATSC>> getFlatEit(){
+//        Map<Integer,List<EITsectionATSC>> result = new TreeMap<>();
+//        for(Map.Entry<Integer, List<EITsectionATSC>> entry : int_list.entrySet()){
+//            int source_id = entry.getKey();
+//            result.merge(source_id,entry.getValue(), );
+//        }
+        return int_list;
+    }
+
+    public static BigInteger get_first_event_start_time(TreeMap<Integer, List<EITsectionATSC>> int_list){
+//        int sourceID = 0;
+//        List<EITsectionATSC> value = new ArrayList<>();
+//        for (Map.Entry<Integer, List<EITsectionATSC>> entry : int_list.entrySet()) {
+//            sourceID = entry.getKey();
+//            value = entry.getValue();
+//            break;
+//        }
+//        EITsectionATSC first_eit = value.get(0);
+//        EITsectionATSC last_eit = value.get(value.size()-1);
+//        EITsectionATSC.Event first_event = first_eit.getEventList().getFirst();
+//        EITsectionATSC.Event last_event = last_eit.getEventList().getLast();
+//        BigInteger first_event_start_time = first_event.getStart_time();
+//        BigInteger last_event_start_time = last_event.getStart_time();
+//        return first_event_start_time;
+
+//        long temp = Long.MAX_VALUE;
+//        for (Map.Entry<Integer, List<EITsectionATSC>> entry : int_list.entrySet()) {
+//            List<EITsectionATSC> eit_list = entry.getValue();
+//            for (EITsectionATSC item : eit_list) {
+//                for (EITsectionATSC.Event event : item.getEventList()) {
+//                    if(event.getStart_time().longValue() < temp){
+//                        temp = event.getStart_time().longValue();
+//                    }
+//                }
+//            }
+//        }
+//        if(temp != Long.MAX_VALUE){
+//            BigInteger first_event_start_time = BigInteger.valueOf(temp);
+//            return first_event_start_time;
+//        }else{
+//            return new BigInteger("0");
+//        }
+
+        long temp = Long.MAX_VALUE;
+        for (Map.Entry<Integer, List<EITsectionATSC>> entry : int_list.entrySet()) {
+            List<EITsectionATSC> eit_list = new ArrayList<>();
+            try{
+                eit_list = entry.getValue();
+            }catch (RuntimeException e){
+                continue;
+            }
+            for (EITsectionATSC item : eit_list) {
+                List<Event> eventList;
+                try {
+                    eventList = item.getEventList();
+                }catch (RuntimeException e){
+                    continue;
+                }
+                for (EITsectionATSC.Event event : eventList) {
+                    if(event.getStart_time().longValue() < temp){
+                        temp = event.getStart_time().longValue();
+                    }
+                }
+            }
+        }
+        if(temp != Long.MAX_VALUE){
+            BigInteger first_event_start_time = BigInteger.valueOf(temp);
+            return first_event_start_time;
+        }else{
+            return new BigInteger("0");
+        }
+
+    }
+
+    public static BigInteger get_last_event_start_time(TreeMap<Integer, List<EITsectionATSC>> int_list){
+        int sourceID = 0;
+        List<EITsectionATSC> value = new ArrayList<>();
+        for (Map.Entry<Integer, List<EITsectionATSC>> entry : int_list.entrySet()) {
+            sourceID = entry.getKey();
+            value = entry.getValue();
+            break;
+        }
+        EITsectionATSC first_eit = value.getFirst();
+        EITsectionATSC last_eit = value.getLast();
+        EITsectionATSC.Event first_event = first_eit.getEventList().getFirst();
+        EITsectionATSC.Event last_event = last_eit.getEventList().getLast();
+        BigInteger first_event_start_time = first_event.getStart_time();
+        BigInteger last_event_start_time = last_event.getStart_time();
+
+        return last_event_start_time;
+    }
+
+    public static BigInteger get_last_event_end_time(TreeMap<Integer, List<EITsectionATSC>> int_list){
+//        int sourceID = 0;
+//        List<EITsectionATSC> value = new ArrayList<>();
+//        for (Map.Entry<Integer, List<EITsectionATSC>> entry : int_list.entrySet()) {
+//            sourceID = entry.getKey();
+//            value = entry.getValue();
+//            break;
+//        }
+//        EITsectionATSC first_eit = value.getFirst();
+//        EITsectionATSC last_eit = value.getLast();
+//        EITsectionATSC.Event first_event = first_eit.getEventList().getFirst();
+//        EITsectionATSC.Event last_event = last_eit.getEventList().getLast();
+//        BigInteger first_event_start_time = first_event.getStart_time();
+//        BigInteger last_event_start_time = last_event.getStart_time();
+//        BigInteger length = BigInteger.valueOf(last_event.getLength_in_seconds());
+//
+//        return last_event_start_time.add(length);
+
+//        long temp = 0;
+//        int length = 0;
+//        for (Map.Entry<Integer, List<EITsectionATSC>> entry : int_list.entrySet()) {
+//            List<EITsectionATSC> eit_list = entry.getValue();
+//            for (EITsectionATSC item : eit_list) {
+//                for (EITsectionATSC.Event event : item.getEventList()) {
+//                    if((event.getStart_time().longValue()+event.getLength_in_seconds()) > temp){
+//                        temp = event.getStart_time().longValue()+event.getLength_in_seconds();
+//                    }
+//                }
+//            }
+//        }
+//        BigInteger last_event_end_time = BigInteger.valueOf(temp);
+//
+//        return last_event_end_time;
+
+        long temp = 0;
+        int length = 0;
+        for (Map.Entry<Integer, List<EITsectionATSC>> entry : int_list.entrySet()) {
+            List<EITsectionATSC> eit_list = new ArrayList<>();
+            try{
+                eit_list = entry.getValue();
+            }catch (RuntimeException e){
+                continue;
+            }
+            for (EITsectionATSC item : eit_list) {
+                List<Event> eventList;
+                try {
+                    eventList = item.getEventList();
+                }catch (RuntimeException e){
+                    continue;
+                }
+                for (EITsectionATSC.Event event : eventList) {
+                    if((event.getStart_time().longValue()+event.getLength_in_seconds()) > temp){
+                        temp = event.getStart_time().longValue()+event.getLength_in_seconds();
+                    }
+                }
+            }
+        }
+        BigInteger last_event_end_time = BigInteger.valueOf(temp);
+
+        return last_event_end_time;
+    }
+
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/EITsectionATSC.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/EITsectionATSC.java
new file mode 100644
index 0000000..6ad8cba
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/EITsectionATSC.java
@@ -0,0 +1,242 @@
+package nl.digitalekabeltelevisie.data.mpeg.psi;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.controller.TreeNode;
+import nl.digitalekabeltelevisie.data.mpeg.PID;
+import nl.digitalekabeltelevisie.data.mpeg.PsiSectionData;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.DescriptorFactory;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.atsc.MSSdescriptor;
+import nl.digitalekabeltelevisie.util.Utils;
+import nl.digitalekabeltelevisie.util.tablemodel.FlexTableModel;
+
+import javax.swing.table.TableModel;
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.math.BigInteger;
+import java.time.Duration;
+import java.time.Instant;
+import java.time.LocalDateTime;
+import java.time.ZoneOffset;
+import java.time.format.DateTimeFormatter;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+
+import static nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor.findGenericDescriptorsInList;
+
+public class EITsectionATSC extends TableSection{
+    private int protocol_version;
+    private int num_events_in_section;
+    private List<Event> eventList;
+
+    private BigInteger stt_offset;  // GPS_UTC_offset  from  STT
+    public EITsectionATSC(PsiSectionData raw_data, PID parent) {
+        super(raw_data, parent);
+
+        stt_offset = this.getPSI().getStt().get_offset();
+
+        byte[] data = raw_data.getData();
+        int offset = 8;
+        protocol_version = Utils.getInt(data,offset,1,Utils.MASK_8BITS);
+        offset += 1;
+        num_events_in_section = Utils.getInt(data,offset,1,Utils.MASK_8BITS);
+        offset += 1;
+        eventList = new ArrayList<>();
+        for (int i = 0; i < num_events_in_section; i++) {
+            Event event = new Event();
+            event.setEvent_id(Utils.getInt(data,offset,2,Utils.MASK_14BITS));
+            offset += 2;
+            event.setStart_time(Utils.getBigInteger(data,offset,4));
+            offset += 4;
+            byte temp = Arrays.copyOfRange(data,offset,offset+1)[0];
+            event.setETM_location(Utils.getBitsATSC(temp,2,2));
+            event.setLength_in_seconds(Utils.getInt(data,offset,3,Utils.MASK_20BITS));
+            offset += 3;
+            event.setTitle_length(Utils.getInt(data,offset,1,Utils.MASK_8BITS));
+            offset += 1;
+//            event.setTitle_text(DescriptorFactory.buildMultipleStringStructure(data,offset,event.getTitle_length(),this));
+            event.setTitle_text(DescriptorFactory.buildMSSdescriptor(data,offset,event.getTitle_length()));
+            offset += event.getTitle_length();
+            event.setDescriptors_length(Utils.getInt(data,offset,2,Utils.MASK_12BITS));
+            offset += 2;
+            event.setDescriptorList(DescriptorFactory.buildDescriptorList(data,offset,event.getDescriptors_length(),this));
+            offset += event.getDescriptors_length();
+            eventList.add(event);
+        }
+    }
+
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        final DefaultMutableTreeNode t = super.getJTreeNode(modus);
+        ((KVP) t.getUserObject()).setTableSource(this::getTableModel);
+        t.add(new DefaultMutableTreeNode(new KVP("protocol_version",protocol_version,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("num_events_in_section",num_events_in_section,null)));
+        Utils.addListJTree(t,eventList,modus,"EventList");
+        return t;
+    }
+
+    public TableModel getTableModel(){
+        FlexTableModel<EITsectionATSC, EITsectionATSC.Event> tableModel = new FlexTableModel<>(EITATSC.buildEITATSCTableHeader());
+        tableModel.addData(this,getEventList());
+        tableModel.process();
+        return tableModel;
+    }
+
+    @Override
+    protected String getTableIdExtensionLabel() {
+        return "source_id";
+    }
+
+    public class Event implements TreeNode{
+        private int event_id;
+        private BigInteger start_time;
+        private int ETM_location;
+        private int length_in_seconds;
+        private int title_length;
+        private List<MSSdescriptor> title_text;   // multiple string structure
+        private int descriptors_length;
+        private List<Descriptor> descriptorList;
+        // content_advisory_descriptor(), caption_service_descriptor() and AC-3 audio_stream_descriptor()
+
+        @Override
+        public DefaultMutableTreeNode getJTreeNode(int modus) {
+            final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("event"));
+            t.add(new DefaultMutableTreeNode(new KVP("event_id",event_id,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("start_time",start_time,STTsection.convertGpsTimeToUtc(start_time,stt_offset))));
+            t.add(new DefaultMutableTreeNode(new KVP("ETM_location",ETM_location,explain_ETM_location(ETM_location))));
+            t.add(new DefaultMutableTreeNode(new KVP("length_in_seconds",length_in_seconds,explain_length_in_seconds(length_in_seconds))));
+            t.add(new DefaultMutableTreeNode(new KVP("title_length",title_length,null)));
+            Utils.addListJTree(t,title_text,modus,"title_text");
+            t.add(new DefaultMutableTreeNode(new KVP("descriptors_length",descriptors_length,null)));
+            Utils.addListJTree(t,descriptorList,modus,"descriptors");
+            return t;
+        }
+
+        public int getEvent_id() {
+            return event_id;
+        }
+
+        public void setEvent_id(int event_id) {
+            this.event_id = event_id;
+        }
+
+        public BigInteger getStart_time() {
+            return start_time;
+        }
+
+        public void setStart_time(BigInteger start_time) {
+            this.start_time = start_time;
+        }
+
+        public int getETM_location() {
+            return ETM_location;
+        }
+
+        public void setETM_location(int ETM_location) {
+            this.ETM_location = ETM_location;
+        }
+
+        public int getLength_in_seconds() {
+            return length_in_seconds;
+        }
+
+        public void setLength_in_seconds(int length_in_seconds) {
+            this.length_in_seconds = length_in_seconds;
+        }
+
+        public int getTitle_length() {
+            return title_length;
+        }
+
+        public void setTitle_length(int title_length) {
+            this.title_length = title_length;
+        }
+
+        public List<MSSdescriptor> getTitle_text() {
+            return title_text;
+        }
+
+        public void setTitle_text(List<MSSdescriptor> title_text) {
+            this.title_text = title_text;
+        }
+
+        public int getDescriptors_length() {
+            return descriptors_length;
+        }
+
+        public void setDescriptors_length(int descriptors_length) {
+            this.descriptors_length = descriptors_length;
+        }
+
+        public List<Descriptor> getDescriptorList() {
+            return descriptorList;
+        }
+
+        public void setDescriptorList(List<Descriptor> descriptorList) {
+            this.descriptorList = descriptorList;
+        }
+    }
+
+    public int getProtocol_version() {
+        return protocol_version;
+    }
+
+    public void setProtocol_version(int protocol_version) {
+        this.protocol_version = protocol_version;
+    }
+
+    public int getNum_events_in_section() {
+        return num_events_in_section;
+    }
+
+    public void setNum_events_in_section(int num_events_in_section) {
+        this.num_events_in_section = num_events_in_section;
+    }
+
+    public List<Event> getEventList() {
+        return eventList;
+    }
+
+    public void setEventList(List<Event> eventList) {
+        this.eventList = eventList;
+    }
+
+//    public static String convertGpsTimeToUtc(BigInteger gpsSeconds) {
+//        Instant GPS_EPOCH_START = LocalDateTime.of(1980, 1, 6, 0, 0, 0).toInstant(ZoneOffset.UTC);
+//        // 使用 GPS 初始时间加上给定的秒数，创建一个新的时间点
+//        Instant targetTime = GPS_EPOCH_START.plus(Duration.ofSeconds(gpsSeconds.longValue()));
+//
+//        // 格式化输出时间
+//        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").withZone(ZoneOffset.UTC);
+//        return dateTimeFormatter.format(targetTime);
+//    }
+
+    public static String explain_ETM_location(int ETM_location){
+        StringBuilder s = new StringBuilder();
+        if(ETM_location == 0){
+            s.append("No ETM");
+        }
+        if(ETM_location == 1){
+            s.append("ETM located in the PTC carrying this PSIP");
+        }
+        if(ETM_location == 2){
+            s.append("ETM located in the PTC carrying this event");
+        }
+        if(ETM_location == 3){
+            s.append("[Reserved for future ATSC use]");
+        }
+        return s.toString();
+    }
+
+    public static String explain_length_in_seconds(int totalSeconds){
+
+        int hours = totalSeconds / 3600; // 1小时有3600秒
+        int minutes = (totalSeconds % 3600) / 60; // 剩余的秒数转换为分钟
+        int seconds = totalSeconds % 60; // 剩余的秒数直接就是秒
+
+            // 格式化为 hh:mm:ss
+        return String.format("%02d:%02d:%02d", hours, minutes, seconds);
+//        return "Duration of this event in seconds.";
+    }
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/ETT.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/ETT.java
new file mode 100644
index 0000000..e6ec258
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/ETT.java
@@ -0,0 +1,110 @@
+package nl.digitalekabeltelevisie.data.mpeg.psi;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.data.mpeg.PSI;
+import nl.digitalekabeltelevisie.util.Utils;
+import nl.digitalekabeltelevisie.util.tablemodel.FlexTableModel;
+import nl.digitalekabeltelevisie.util.tablemodel.TableHeader;
+import nl.digitalekabeltelevisie.util.tablemodel.TableHeaderBuilder;
+
+import javax.swing.table.TableModel;
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+
+import static nl.digitalekabeltelevisie.util.Utils.addListJTree;
+import static nl.digitalekabeltelevisie.util.Utils.simpleModus;
+
+public class ETT extends AbstractPSITabel{
+    private final List<ETTsection> ettSectionList = new ArrayList<>();
+
+//    private final Map<Integer, ETTsection[]> newEtt = new TreeMap<>();
+    private final TreeMap<Integer, List<ETTsection>> sourceId_ettList = new TreeMap<>();
+
+    public ETT(PSI parentPSI) {
+        super(parentPSI);
+    }
+
+
+//    public void update(final ETTsection section){
+//        if(!ettSectionList.contains(section)){
+//            ettSectionList.add(section);
+//        }
+//    }
+
+    public void update(final ETTsection section){
+        byte[] etm_id = section.getETM_id();
+        int source_id = Utils.getBitsFromByteArray(etm_id,0,16);
+        List<ETTsection> list = sourceId_ettList.computeIfAbsent(source_id, k -> new ArrayList<>());
+        if(!list.contains(section)){
+            list.add(section);
+        }
+    }
+
+//    @Override
+//    public DefaultMutableTreeNode getJTreeNode(int modus) {
+//        KVP kvp = new KVP("ETT");
+//        final DefaultMutableTreeNode t = new DefaultMutableTreeNode(kvp);
+//        if(!ettSectionList.isEmpty()){
+//            kvp.setTableSource(this::getTableModel);
+//        }
+//        for (ETTsection item : ettSectionList) {
+//            t.add(item.getJTreeNode(modus));
+//        }
+//        return t;
+//    }
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        final KVP eitKVP = new KVP("ETT");
+        final DefaultMutableTreeNode t = new DefaultMutableTreeNode(eitKVP);
+        for(Map.Entry<Integer, List<ETTsection>> entry : sourceId_ettList.entrySet()){
+            Integer source_id = entry.getKey();
+            List<ETTsection> sections = entry.getValue();
+            final KVP tableNodeKVP = new KVP("source_id",source_id,null);
+            final DefaultMutableTreeNode tableNode = new DefaultMutableTreeNode(tableNodeKVP);
+            for (ETTsection section : sections) {
+                if(section!= null){
+                    if(!simpleModus(modus)){
+                        addSectionVersionsToJTree(tableNode, section, modus);
+                    }else{
+                        addListJTree(tableNode,section.getExtended_text_message(),modus,"events");
+                    }
+                }
+            }
+            t.add(tableNode);
+        }
+        return t;
+    }
+
+
+    static TableHeader<ETTsection,ETTsection> buildETTTableHeader() {
+        return new TableHeaderBuilder<ETTsection,ETTsection>()
+                .addRequiredBaseColumn("ETT_table_id_extension",ETTsection::getTableIdExtension,Integer.class)
+                .addOptionalRowColumn("ETM_id",ETTsection::get_ETM_id_string,String.class)
+                .addRequiredBaseColumn("Extended_text_message",ETTsection::get_text_string,String.class)
+                .build();
+    }
+
+    public TableModel getTableModel(){
+        FlexTableModel<ETTsection,ETTsection> tableModel = new FlexTableModel<>(buildETTTableHeader());
+
+        for (ETTsection item : ettSectionList) {
+            if(item != null){
+                tableModel.addData(item,List.of(item));
+            }
+        }
+
+        tableModel.process();
+        return tableModel;
+    }
+
+    public List<ETTsection> getEttSectionList() {
+        return ettSectionList;
+    }
+
+    public TreeMap<Integer, List<ETTsection>> getSourceId_ettList() {
+        return sourceId_ettList;
+    }
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/ETTsection.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/ETTsection.java
new file mode 100644
index 0000000..18dcee9
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/ETTsection.java
@@ -0,0 +1,113 @@
+package nl.digitalekabeltelevisie.data.mpeg.psi;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.data.mpeg.PID;
+import nl.digitalekabeltelevisie.data.mpeg.PsiSectionData;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.DescriptorFactory;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.atsc.MSSdescriptor;
+import nl.digitalekabeltelevisie.util.Utils;
+import nl.digitalekabeltelevisie.util.tablemodel.FlexTableModel;
+
+import javax.swing.table.TableModel;
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class ETTsection extends TableSection{
+    private int protocol_version;
+    private byte[] ETM_id;
+    private List<MSSdescriptor> extended_text_message;
+    public ETTsection(PsiSectionData raw_data, PID parent) {
+        super(raw_data, parent);
+        byte[] data = raw_data.getData();
+        int offset = 8;
+        protocol_version = Utils.getInt(data,offset,1,Utils.MASK_8BITS);
+        offset += 1;
+        ETM_id = Arrays.copyOfRange(data,offset,offset+4);
+        offset += 4;
+
+        extended_text_message = DescriptorFactory.buildMSSdescriptor(data,offset,this.getSectionLength()-14);
+    }
+
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        final DefaultMutableTreeNode t = super.getJTreeNode(modus);
+        ((KVP) t.getUserObject()).setTableSource(this::getTableModel);
+        t.add(new DefaultMutableTreeNode(new KVP("protocol_version",protocol_version,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("ETM_id",ETM_id,explain_ETM_id(ETM_id))));
+        Utils.addListJTree(t,extended_text_message,modus,"extended_text_message");
+        return t;
+    }
+
+    public TableModel getTableModel(){
+        FlexTableModel<ETTsection, ETTsection> tableModel = new FlexTableModel<>(ETT.buildETTTableHeader());
+        List<ETTsection> item = new ArrayList<>();
+        item.add(this);
+
+        tableModel.addData(this,item);
+        tableModel.process();
+        return tableModel;
+    }
+
+    @Override
+    protected String getTableIdExtensionLabel() {
+        return "ETT_table_id_extension";
+    }
+
+    public int getProtocol_version() {
+        return protocol_version;
+    }
+
+    public void setProtocol_version(int protocol_version) {
+        this.protocol_version = protocol_version;
+    }
+
+    public byte[] getETM_id() {
+        return ETM_id;
+    }
+
+    public String get_ETM_id_string(){
+        return explain_ETM_id(this.ETM_id);
+    }
+
+    public void setETM_id(byte[] ETM_id) {
+        this.ETM_id = ETM_id;
+    }
+
+    public List<MSSdescriptor> getExtended_text_message() {
+        return extended_text_message;
+    }
+
+    public String get_text_string(){
+        try{
+//            byte[] compressedStringByte = this.getExtended_text_message().getFirst().
+//                    getDescriptorStringList().getFirst().
+//                    getSegmentList().getFirst().
+//                    getCompressed_string_byte();
+//            return Utils.hexToAsciiString(compressedStringByte);
+            return MSSdescriptor.get_multi_string(this.getExtended_text_message());
+        }catch (RuntimeException e){
+            return "";
+        }
+    }
+
+    public void setExtended_text_message(List<MSSdescriptor> extended_text_message) {
+        this.extended_text_message = extended_text_message;
+    }
+
+    public static String explain_ETM_id (byte[] ETM_id){
+        StringBuilder s = new StringBuilder();
+        int LSB = Utils.getInt(ETM_id,0,ETM_id.length,Utils.MASK_2BITS);
+        int source_id = Utils.getBitsFromByteArray(ETM_id,0,16);
+        int event_id = Utils.getBitsFromByteArray(ETM_id,16,14);
+        if(LSB == 0){
+            s.append("this is channel ETM_id,source_id = ").append(source_id);
+        } else if (LSB == 2) {
+            s.append("this is event ETM_id,source_id = ").append(source_id)
+                    .append(",event_id = ").append(event_id);
+        }
+        return s.toString();
+    }
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/MGT.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/MGT.java
new file mode 100644
index 0000000..de9534a
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/MGT.java
@@ -0,0 +1,74 @@
+package nl.digitalekabeltelevisie.data.mpeg.psi;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.data.mpeg.PSI;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.LocalTimeOffsetDescriptor;
+import nl.digitalekabeltelevisie.util.tablemodel.FlexTableModel;
+import nl.digitalekabeltelevisie.util.tablemodel.TableHeader;
+import nl.digitalekabeltelevisie.util.tablemodel.TableHeaderBuilder;
+
+import nl.digitalekabeltelevisie.data.mpeg.psi.MGTsection.TablesInfo;
+
+import javax.swing.table.TableModel;
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.util.ArrayList;
+import java.util.List;
+
+import static nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor.findGenericDescriptorsInList;
+
+public class MGT extends AbstractPSITabel{
+    private final List<MGTsection> mgTsectionList = new ArrayList<>();
+
+    public MGT(PSI parentPSI) {
+        super(parentPSI);
+    }
+
+    public void update(final MGTsection mgTsection){
+        if(!mgTsectionList.contains(mgTsection)){
+            mgTsectionList.add(mgTsection);
+        }
+    }
+
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        KVP kvp = new KVP("MGT");
+        if(!mgTsectionList.isEmpty()){
+            kvp.setTableSource(this::getTableModel);
+        }
+        final DefaultMutableTreeNode t = new DefaultMutableTreeNode(kvp);
+        for (MGTsection item : mgTsectionList) {
+            t.add(item.getJTreeNode(modus));
+        }
+        return t;
+    }
+    public static TableHeader<MGTsection, TablesInfo> buildMGTTableHeader() {
+        return new TableHeaderBuilder<MGTsection, TablesInfo>()
+                .addOptionalRowColumn("table_type",TablesInfo::getTable_type,Integer.class)
+                .addOptionalRowColumn("table_type_PID",TablesInfo::getTable_type_PID,Integer.class)
+                .addOptionalRowColumn("table_type_version_number",TablesInfo::getTable_type_version_number,Integer.class)
+                .addOptionalRowColumn("number_bytes",TablesInfo::getNumber_bytes,Integer.class)
+                .build();
+//                .addRequiredBaseColumn("Protocol_version",MGTsection::getProtocol_version,Integer.class)
+//                .addRequiredBaseColumn("Tables_defined",MGTsection::getTables_defined,Integer.class)
+//                .addRequiredBaseColumn("TablesInfoList",MGTsection::getTablesInfoList, List.class)
+//                .addRequiredBaseColumn("Descriptors_length",MGTsection::getDescriptors_length,Integer.class)
+//                .addRequiredBaseColumn("DescriptorList",MGTsection::getDescriptorList, List.class)
+//                .build();
+    }
+
+    public TableModel getTableModel(){
+
+        FlexTableModel<MGTsection, TablesInfo> tableModel = new FlexTableModel<>(buildMGTTableHeader());
+        //将sttSectionList的数据添加到表模型中
+        for (MGTsection mgTsection : mgTsectionList) {
+            if(mgTsection != null){
+                tableModel.addData(mgTsection, mgTsection.getTablesInfoList());
+            }
+        }
+        //模型处理
+        tableModel.process();
+        return tableModel;
+    }
+
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/MGTsection.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/MGTsection.java
new file mode 100644
index 0000000..57c0e52
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/MGTsection.java
@@ -0,0 +1,259 @@
+package nl.digitalekabeltelevisie.data.mpeg.psi;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.controller.TreeNode;
+import nl.digitalekabeltelevisie.data.mpeg.PID;
+import nl.digitalekabeltelevisie.data.mpeg.PsiSectionData;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.DescriptorFactory;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.LocalTimeOffsetDescriptor;
+import nl.digitalekabeltelevisie.util.Utils;
+import nl.digitalekabeltelevisie.util.tablemodel.FlexTableModel;
+
+import javax.swing.table.TableModel;
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.List;
+
+import static nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor.findGenericDescriptorsInList;
+
+public class MGTsection extends TableSection{
+    private int protocol_version;
+    private int tables_defined;
+
+    public class TablesInfo implements TreeNode {
+        private int table_type;
+        private int table_type_PID;
+        private int table_type_version_number;
+        private BigInteger number_bytes;
+        private int table_type_descriptors_length;
+        private List<Descriptor> tableTypeDescriptorList;
+
+        @Override
+        public DefaultMutableTreeNode getJTreeNode(int modus) {
+            final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("table_type"));
+            t.add(new DefaultMutableTreeNode(new KVP("table_type",table_type,explain_table_type(table_type))));
+            t.add(new DefaultMutableTreeNode(new KVP("table_type_PID",table_type_PID,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("table_type_version_number",table_type_version_number,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("number_bytes",number_bytes,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("table_type_descriptors_length",table_type_descriptors_length,null)));
+            Utils.addListJTree(t,tableTypeDescriptorList,modus,"table type descriptors");
+            return t;
+        }
+
+        public int getTable_type() {
+            return table_type;
+        }
+
+        public void setTable_type(int table_type) {
+            this.table_type = table_type;
+        }
+
+        public int getTable_type_PID() {
+            return table_type_PID;
+        }
+
+        public void setTable_type_PID(int table_type_PID) {
+            this.table_type_PID = table_type_PID;
+        }
+
+        public int getTable_type_version_number() {
+            return table_type_version_number;
+        }
+
+        public void setTable_type_version_number(int table_type_version_number) {
+            this.table_type_version_number = table_type_version_number;
+        }
+
+        public BigInteger getNumber_bytes() {
+            return number_bytes;
+        }
+
+        public void setNumber_bytes(BigInteger number_bytes) {
+            this.number_bytes = number_bytes;
+        }
+
+        public int getTable_type_descriptors_length() {
+            return table_type_descriptors_length;
+        }
+
+        public void setTable_type_descriptors_length(int table_type_descriptors_length) {
+            this.table_type_descriptors_length = table_type_descriptors_length;
+        }
+
+        public List<Descriptor> getTableTypeDescriptorList() {
+            return tableTypeDescriptorList;
+        }
+
+        public void setTableTypeDescriptorList(List<Descriptor> tableTypeDescriptorList) {
+            this.tableTypeDescriptorList = tableTypeDescriptorList;
+        }
+
+        public static String explain_table_type(int table_type){
+            StringBuilder s = new StringBuilder();
+            if(table_type == 0){
+                s.append("Terrestrial VCT with current_next_indicator=’1’ ");
+            }
+            if(table_type == 1){
+                s.append("Terrestrial VCT with current_next_indicator=’0’ ");
+            }
+            if(table_type == 2){
+                s.append("Cable VCT with current_next_indicator=’1’ ");
+            }
+            if(table_type == 3){
+                s.append("Cable VCT with current_next_indicator=’0’ ");
+            }
+            if(table_type == 4){
+                s.append("Channel ETT ");
+            }
+            if(table_type == 5){
+                s.append("DCCSCT ");
+            }
+            if(table_type >= 256 && table_type <= 383) {
+                s.append("EIT-").append(table_type-256);
+            }
+            if(table_type >= 512 && table_type <= 639) {
+                s.append("Event ETT-").append(table_type-512);
+            }
+            if(table_type >= 769 && table_type <= 1023) {
+                s.append("RRT with rating_region ").append(table_type-768);
+            }
+            if(table_type >= 5120 && table_type <= 5375) {
+                s.append("DCCT with dcc_id 0x").append(Integer.toHexString(table_type - 5120).toUpperCase());
+            }
+            return s.toString();
+        }
+    }
+    private List<TablesInfo> tablesInfoList;
+
+
+    private int descriptors_length;
+    private List<Descriptor> descriptorList;
+
+    public MGTsection(PsiSectionData raw_data, PID parent) {
+        super(raw_data, parent);
+        int offset = 8;
+        byte[] data = raw_data.getData();
+        protocol_version = Utils.getInt(data,offset,1,Utils.MASK_8BITS);
+        offset += 1;
+        tables_defined = Utils.getInt(data,offset,2,Utils.MASK_8BITS);
+        offset += 2;
+
+        tablesInfoList = new ArrayList<>();
+
+        for (int i = 0; i < tables_defined; i++) {
+            TablesInfo tablesInfo = new TablesInfo();
+            tablesInfo.setTable_type(Utils.getInt(data,offset,2,Utils.MASK_16BITS));
+            offset += 2;
+            tablesInfo.setTable_type_PID(Utils.getInt(data,offset,2,Utils.MASK_13BITS));
+            offset += 2;
+            tablesInfo.setTable_type_version_number(Utils.getInt(data,offset,1,Utils.MASK_5BITS));
+            offset += 1;
+            tablesInfo.setNumber_bytes(Utils.getBigInteger(data,offset,4));
+            offset += 4;
+            tablesInfo.setTable_type_descriptors_length(Utils.getInt(data,offset,2,Utils.MASK_12BITS));
+            offset += 2;
+            tablesInfo.setTableTypeDescriptorList(DescriptorFactory.buildDescriptorList
+                    (data,offset,tablesInfo.getTable_type_descriptors_length(),this));
+            tablesInfoList.add(tablesInfo);
+            offset += tablesInfo.getTable_type_descriptors_length();
+
+        }
+        descriptors_length = Utils.getInt(data,offset,2,Utils.MASK_12BITS);
+        offset += 2;
+        descriptorList = DescriptorFactory.buildDescriptorList
+                (data,offset,descriptors_length,this);
+
+
+    }
+
+    public DefaultMutableTreeNode getJTreeNode(int modus){
+        final DefaultMutableTreeNode t = super.getJTreeNode(modus);
+        ((KVP) t.getUserObject()).setTableSource(this::getTableModel);
+        t.add(new DefaultMutableTreeNode(new KVP("protocol_version",protocol_version,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("tables_defined",tables_defined,null)));
+        Utils.addListJTree(t,tablesInfoList,modus,"tablesInfoList");
+        t.add(new DefaultMutableTreeNode(new KVP("descriptors_length",descriptors_length,null)));
+        Utils.addListJTree(t,descriptorList,modus,"descriptorList");
+        return t;
+    }
+
+    public TableModel getTableModel() {
+        FlexTableModel<MGTsection, TablesInfo> tableModel = new FlexTableModel<>(MGT.buildMGTTableHeader());
+        tableModel.addData(this, getTablesInfoList());
+        tableModel.process();
+        return tableModel;
+    }
+
+    public int getProtocol_version() {
+        return protocol_version;
+    }
+
+    public void setProtocol_version(int protocol_version) {
+        this.protocol_version = protocol_version;
+    }
+
+    public int getTables_defined() {
+        return tables_defined;
+    }
+
+    public void setTables_defined(int tables_defined) {
+        this.tables_defined = tables_defined;
+    }
+
+    public int getDescriptors_length() {
+        return descriptors_length;
+    }
+
+    public void setDescriptors_length(int descriptors_length) {
+        this.descriptors_length = descriptors_length;
+    }
+
+    public List<Descriptor> getDescriptorList() {
+        return descriptorList;
+    }
+
+    public void setDescriptorList(List<Descriptor> descriptorList) {
+        this.descriptorList = descriptorList;
+    }
+
+    public List<TablesInfo> getTablesInfoList() {
+        return tablesInfoList;
+    }
+
+    public static String explain_table_type(int table_type){
+        StringBuilder s = new StringBuilder();
+        if(table_type == 0){
+            s.append("Terrestrial VCT with current_next_indicator=’1’ ");
+        }
+        if(table_type == 1){
+            s.append("Terrestrial VCT with current_next_indicator=’0’ ");
+        }
+        if(table_type == 2){
+            s.append("Cable VCT with current_next_indicator=’1’ ");
+        }
+        if(table_type == 3){
+            s.append("Cable VCT with current_next_indicator=’0’ ");
+        }
+        if(table_type == 4){
+            s.append("Channel ETT ");
+        }
+        if(table_type == 5){
+            s.append("DCCSCT ");
+        }
+        if(table_type >= 256 && table_type <= 383) {
+            s.append("EIT-").append(table_type-256);
+        }
+        if(table_type >= 512 && table_type <= 639) {
+            s.append("Event ETT-").append(table_type-512);
+        }
+        if(table_type >= 769 && table_type <= 1023) {
+            s.append("RRT with rating_region ").append(table_type-768);
+        }
+        if(table_type >= 5120 && table_type <= 5375) {
+            s.append("DCCT with dcc_id 0x").append(Integer.toHexString(table_type - 5120).toUpperCase());
+        }
+        return s.toString();
+    }
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/RRT.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/RRT.java
new file mode 100644
index 0000000..e5e9a01
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/RRT.java
@@ -0,0 +1,70 @@
+package nl.digitalekabeltelevisie.data.mpeg.psi;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.data.mpeg.PSI;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.atsc.MSSdescriptor;
+import nl.digitalekabeltelevisie.data.mpeg.psi.RRTsection.Dimension;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.util.tablemodel.FlexTableModel;
+import nl.digitalekabeltelevisie.util.tablemodel.TableHeader;
+import nl.digitalekabeltelevisie.util.tablemodel.TableHeaderBuilder;
+
+import javax.swing.table.TableModel;
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.util.ArrayList;
+import java.util.List;
+
+import static nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor.findGenericDescriptorsInList;
+
+//author:dinghang.men
+
+public class RRT extends AbstractPSITabel{
+    private final List<RRTsection> rrTsectionList = new ArrayList<>();
+    public RRT(PSI parentPSI) {
+        super(parentPSI);
+    }
+
+    public void update(final RRTsection rrTsection){
+        if(!rrTsectionList.contains(rrTsection)){
+            rrTsectionList.add(rrTsection);
+        }
+    }
+
+    static TableHeader<RRTsection, Dimension> buildRRTTableHeader() {
+        return new TableHeaderBuilder<RRTsection,Dimension>()
+                .addRequiredBaseColumn("rating_region",RRTsection::get_rating_region,Integer.class)
+                .addRequiredBaseColumn("Rating_region_name_text",RRTsection::get_name_string, String.class)
+                .addOptionalRowColumn("Dimension_name", Dimension::getDimension_name_string,String.class)
+                .addOptionalRowColumn("rating_value",Dimension::get_Abbrev_String,String.class)
+                .build();
+    }
+    
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        KVP kvp = new KVP("RRT");
+        if(!rrTsectionList.isEmpty()){
+            kvp.setTableSource(this::getTableModel);
+        }
+        final DefaultMutableTreeNode t = new DefaultMutableTreeNode(kvp);
+        for (RRTsection item : rrTsectionList) {
+            t.add(item.getJTreeNode(modus));
+        }
+        return t;
+    }
+
+    public TableModel getTableModel(){
+        //创建表模型
+        FlexTableModel<RRTsection, Dimension> tableModel = new FlexTableModel<>(buildRRTTableHeader());
+        //将sttSectionList的数据添加到表模型中
+        for (RRTsection item : rrTsectionList) {
+            if(item != null){
+                tableModel.addData(item,item.getDimensionList());
+            }
+        }
+        //模型处理
+        tableModel.process();
+        return tableModel;
+    }
+
+
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/RRTsection.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/RRTsection.java
new file mode 100644
index 0000000..bc3118f
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/RRTsection.java
@@ -0,0 +1,343 @@
+package nl.digitalekabeltelevisie.data.mpeg.psi;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.controller.TreeNode;
+import nl.digitalekabeltelevisie.data.mpeg.PID;
+import nl.digitalekabeltelevisie.data.mpeg.PsiSectionData;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.DescriptorFactory;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.atsc.MSSdescriptor;
+import nl.digitalekabeltelevisie.util.Utils;
+import nl.digitalekabeltelevisie.util.tablemodel.FlexTableModel;
+
+import javax.swing.table.TableModel;
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static java.util.Arrays.copyOfRange;
+import static nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor.findGenericDescriptorsInList;
+
+public class RRTsection extends TableSection{
+    private int protocol_version;
+    private int rating_region_name_length;
+    private List<MSSdescriptor> rating_region_name_text;
+    private int dimensions_defined;
+    public class Dimension implements TreeNode {
+        private int dimension_name_length;
+        private List<MSSdescriptor> dimension_name_text;
+        private int graduated_scale;
+        private int values_defined;
+        public class Abbrev implements TreeNode {
+            private int abbrev_rating_value_length;
+            private List<MSSdescriptor> abbrev_rating_value_text;
+            private int rating_value_length;
+            private List<MSSdescriptor> rating_value_text;
+
+            @Override
+            public DefaultMutableTreeNode getJTreeNode(int modus) {
+                final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("abbrev"));
+                t.add(new DefaultMutableTreeNode(new KVP("abbrev_rating_value_length",abbrev_rating_value_length,null)));
+//                t.add(new DefaultMutableTreeNode(new KVP("abbrev_rating_value_text",abbrev_rating_value_text,null)));
+                Utils.addListJTree(t,abbrev_rating_value_text,modus,"abbrev_rating_value_text");
+                t.add(new DefaultMutableTreeNode(new KVP("rating_value_length",rating_value_length,null)));
+//                t.add(new DefaultMutableTreeNode(new KVP("rating_value_text",rating_value_text,null)));
+                Utils.addListJTree(t,rating_value_text,modus,"rating_value_text");
+                return t;
+            }
+
+            public int getAbbrev_rating_value_length() {
+                return abbrev_rating_value_length;
+            }
+
+            public void setAbbrev_rating_value_length(int abbrev_rating_value_length) {
+                this.abbrev_rating_value_length = abbrev_rating_value_length;
+            }
+
+            public List<MSSdescriptor> getAbbrev_rating_value_text() {
+                return abbrev_rating_value_text;
+            }
+
+            public void setAbbrev_rating_value_text(List<MSSdescriptor> abbrev_rating_value_text) {
+                this.abbrev_rating_value_text = abbrev_rating_value_text;
+            }
+
+            public int getRating_value_length() {
+                return rating_value_length;
+            }
+
+            public void setRating_value_length(int rating_value_length) {
+                this.rating_value_length = rating_value_length;
+            }
+
+            public List<MSSdescriptor> getRating_value_text() {
+                return rating_value_text;
+            }
+
+            public void setRating_value_text(List<MSSdescriptor> rating_value_text) {
+                this.rating_value_text = rating_value_text;
+            }
+        }
+        private List<Abbrev> abbrevList;
+
+
+        @Override
+        public DefaultMutableTreeNode getJTreeNode(int modus) {
+            final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("dimension"));
+            t.add(new DefaultMutableTreeNode(new KVP("dimension_name_length",dimension_name_length,null)));
+//            t.add(new DefaultMutableTreeNode(new KVP("dimension_name_text",dimension_name_text,null)));
+            Utils.addListJTree(t,dimension_name_text,modus,"dimension_name_text");
+            t.add(new DefaultMutableTreeNode(new KVP("graduated_scale",graduated_scale,explain_graduated_scale(graduated_scale))));
+            t.add(new DefaultMutableTreeNode(new KVP("values_defined",values_defined,null)));
+            Utils.addListJTree(t,abbrevList,modus,"abbrevList");
+            return t;
+        }
+
+        public int getDimension_name_length() {
+            return dimension_name_length;
+        }
+
+        public void setDimension_name_length(int dimension_name_length) {
+            this.dimension_name_length = dimension_name_length;
+        }
+
+        public List<MSSdescriptor> getDimension_name_text() {
+            return dimension_name_text;
+        }
+
+        public String getDimension_name_string(){
+            return MSSdescriptor.get_multi_string(this.getDimension_name_text());
+        }
+
+        public void setDimension_name_text(List<MSSdescriptor> dimension_name_text) {
+            this.dimension_name_text = dimension_name_text;
+        }
+
+        public int getGraduated_scale() {
+            return graduated_scale;
+        }
+
+        public void setGraduated_scale(int graduated_scale) {
+            this.graduated_scale = graduated_scale;
+        }
+
+        public int getValues_defined() {
+            return values_defined;
+        }
+
+        public void setValues_defined(int values_defined) {
+            this.values_defined = values_defined;
+        }
+
+        public List<Abbrev> getAbbrevList() {
+            return abbrevList;
+        }
+
+        public void setAbbrevList(List<Abbrev> abbrevList) {
+            this.abbrevList = abbrevList;
+        }
+
+        public String get_Abbrev_String(){
+            StringBuilder s = new StringBuilder();
+
+            try{
+                s.append("rating_value = [");
+                for (Abbrev abbrev : abbrevList) {
+                    s.append(MSSdescriptor.get_multi_string(abbrev.rating_value_text)).append(",");
+                }
+                s.append("]");
+            }catch (RuntimeException e){
+                return s.toString();
+            }
+            return s.toString();
+        }
+    }
+
+    private List<Dimension> dimensionList;
+
+    private int descriptors_length;
+
+    private List<Descriptor> descriptorList;
+    public RRTsection(PsiSectionData raw_data, PID parent) {
+        super(raw_data, parent);
+        int offset = 8;
+        byte[] data = raw_data.getData();
+        protocol_version = Utils.getInt(data,offset,1,Utils.MASK_8BITS);
+        offset += 1;
+        rating_region_name_length = Utils.getInt(data,offset,1,Utils.MASK_8BITS);
+        offset += 1;
+//        rating_region_name_text = copyOfRange(data,offset,offset+rating_region_name_length);
+        rating_region_name_text = DescriptorFactory.buildMSSdescriptor(data,offset,rating_region_name_length);
+        offset += rating_region_name_length;
+        dimensions_defined = Utils.getInt(data,offset,1,Utils.MASK_8BITS);
+        offset += 1;
+        dimensionList = new ArrayList<>();
+        for (int i = 0; i < dimensions_defined; i++) {
+            Dimension dimension = new Dimension();
+            dimension.setDimension_name_length(Utils.getInt(data,offset,1,Utils.MASK_8BITS));
+            offset += 1;
+//            dimension.setDimension_name_text(copyOfRange(data,offset,
+//                    offset+dimension.dimension_name_length));
+            dimension.setDimension_name_text(DescriptorFactory.buildMSSdescriptor(data,offset,dimension.getDimension_name_length()));
+            offset += dimension.getDimension_name_length();
+            byte temp = Arrays.copyOfRange(data,offset,offset+1)[0];
+            dimension.setGraduated_scale(Utils.getBitATSC(temp,3));
+            dimension.setValues_defined(Utils.getInt(data,offset,1,Utils.MASK_4BITS));
+            offset += 1;
+            dimension.abbrevList = new ArrayList<>();
+            for (int j = 0; j < dimension.getValues_defined(); j++) {
+                Dimension.Abbrev abbrev = dimension.new Abbrev();
+                abbrev.setAbbrev_rating_value_length(Utils.getInt(data,offset,1,Utils.MASK_8BITS));
+                offset += 1;
+//                abbrev.setAbbrev_rating_value_text(copyOfRange(data,offset,offset+abbrev.getAbbrev_rating_value_length()));
+                try{
+                    abbrev.setAbbrev_rating_value_text(DescriptorFactory.buildMSSdescriptor(data,offset,abbrev.getAbbrev_rating_value_length()));
+                }catch (RuntimeException E){
+                    abbrev.setAbbrev_rating_value_text(null);
+                }
+
+                offset += abbrev.getAbbrev_rating_value_length();
+                abbrev.setRating_value_length(Utils.getInt(data,offset,1,Utils.MASK_8BITS));
+                offset += 1;
+//                abbrev.setRating_value_text(copyOfRange(data,offset,offset+ abbrev.getRating_value_length()));
+                try{
+                    abbrev.setRating_value_text(DescriptorFactory.buildMSSdescriptor(data,offset,abbrev.getRating_value_length()));
+                }catch (RuntimeException E){
+                    abbrev.setRating_value_text(null);
+                }
+
+                offset += abbrev.getRating_value_length();
+                dimension.abbrevList.add(abbrev);
+            }
+            dimensionList.add(dimension);
+        }
+        descriptors_length = Utils.getInt(data,offset,2,Utils.MASK_10BITS);
+        offset += 2;
+        descriptorList = DescriptorFactory.buildDescriptorList(data,offset,descriptors_length,this);
+    }
+
+
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        final DefaultMutableTreeNode t = super.getJTreeNode(modus);
+        ((KVP) t.getUserObject()).setTableSource(this::getTableModel);
+        t.add(new DefaultMutableTreeNode(new KVP("protocol_version",protocol_version,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("rating_region_name_length",rating_region_name_length,null)));
+//        t.add(new DefaultMutableTreeNode(new KVP("rating_region_name_text",rating_region_name_text,null)));
+        Utils.addListJTree(t,rating_region_name_text,modus,"rating_region_name_text");
+        t.add(new DefaultMutableTreeNode(new KVP("dimensions_defined",dimensions_defined,null)));
+        Utils.addListJTree(t,dimensionList,modus,"dimensionList");
+        t.add(new DefaultMutableTreeNode(new KVP("descriptors_length",descriptors_length,null)));
+        Utils.addListJTree(t,descriptorList,modus,"descriptorList");
+        return t;
+    }
+
+    @Override
+    protected String getTableIdExtensionLabel() {
+        return "rating_region";
+    }
+
+    @Override
+    protected String getTableIdExtensionDescription(int tableIdExtension){
+        StringBuilder s = new StringBuilder();
+        s.append("reserved = 0xFF , rating_region = ").append(tableIdExtension - 65280);
+        return s.toString();
+    }
+
+
+
+    public TableModel getTableModel() {
+        FlexTableModel<RRTsection, Dimension> tableModel =  new FlexTableModel<>(RRT.buildRRTTableHeader());
+
+        tableModel.addData(this,getDimensionList());
+        tableModel.process();
+        return tableModel;
+    }
+
+    public int get_rating_region(){
+        return this.getTableIdExtension() - 65280;
+    }
+
+    public int getProtocol_version() {
+        return protocol_version;
+    }
+
+    public void setProtocol_version(int protocol_version) {
+        this.protocol_version = protocol_version;
+    }
+
+    public int getRating_region_name_length() {
+        return rating_region_name_length;
+    }
+
+    public void setRating_region_name_length(int rating_region_name_length) {
+        this.rating_region_name_length = rating_region_name_length;
+    }
+
+    public List<MSSdescriptor> getRating_region_name_text() {
+        return rating_region_name_text;
+    }
+
+    public String get_name_string(){
+        StringBuilder s = new StringBuilder();
+        try{
+            for (MSSdescriptor msSdescriptor : this.rating_region_name_text) {
+                for (MSSdescriptor.DescriptorString string : msSdescriptor.getDescriptorStringList()) {
+                    for (MSSdescriptor.DescriptorString.DescriptorSegment segment : string.getSegmentList()) {
+                        s.append(Utils.hexToAsciiString(segment.getCompressed_string_byte())).append(" ");
+                    }
+                }
+            }
+        }catch (RuntimeException e){
+            return s.toString();
+        }
+        return s.toString();
+    }
+
+    public void setRating_region_name_text(List<MSSdescriptor> rating_region_name_text) {
+        this.rating_region_name_text = rating_region_name_text;
+    }
+
+    public int getDimensions_defined() {
+        return dimensions_defined;
+    }
+
+    public void setDimensions_defined(int dimensions_defined) {
+        this.dimensions_defined = dimensions_defined;
+    }
+
+    public List<Dimension> getDimensionList() {
+        return dimensionList;
+    }
+
+    public void setDimensionList(List<Dimension> dimensionList) {
+        this.dimensionList = dimensionList;
+    }
+
+    public int getDescriptors_length() {
+        return descriptors_length;
+    }
+
+    public void setDescriptors_length(int descriptors_length) {
+        this.descriptors_length = descriptors_length;
+    }
+
+    public List<Descriptor> getDescriptorList() {
+        return descriptorList;
+    }
+
+    public void setDescriptorList(List<Descriptor> descriptorList) {
+        this.descriptorList = descriptorList;
+    }
+
+    public static String explain_graduated_scale(int graduated_scale){
+        StringBuilder s = new StringBuilder();
+        if(graduated_scale == 0){
+            s.append(" the rating values in this dimension does not represent a graduated scale");
+        }else{
+            s.append(" the rating values in this dimension represent a graduated scale");
+        }
+        return s.toString();
+    }
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/STT.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/STT.java
new file mode 100644
index 0000000..93522c8
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/STT.java
@@ -0,0 +1,113 @@
+package nl.digitalekabeltelevisie.data.mpeg.psi;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.data.mpeg.PSI;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.LocalTimeOffsetDescriptor;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.ServiceDescriptor;
+import nl.digitalekabeltelevisie.util.tablemodel.FlexTableModel;
+import nl.digitalekabeltelevisie.util.tablemodel.TableHeader;
+import nl.digitalekabeltelevisie.util.tablemodel.TableHeaderBuilder;
+
+import javax.swing.table.TableModel;
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.List;
+
+import static nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor.*;
+import static nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor.findDescriptorApplyFunc;
+
+/**
+ * STT相关函数
+ * author: dinghang.men
+ */
+
+public class STT extends AbstractPSITabel{
+    private final List<STTsection> sttSectionList = new ArrayList<>();
+
+    /**
+     * 构造函数
+     * @param parentPSI
+     */
+    public STT(PSI parentPSI) {
+        super(parentPSI);
+    }
+
+    /**
+     * @param section
+     */
+    public void update(final STTsection section){
+        if(!sttSectionList.contains(section)){
+            sttSectionList.add(section);
+        }
+    }
+
+    /**
+     * 生成Jtree节点
+     * @param modus
+     * @return
+     */
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        //STT标签
+        KVP kvp = new KVP("STT");
+        if(!sttSectionList.isEmpty()){
+            //设置Table格式
+            kvp.setTableSource(this::getTableModel);
+        }
+        final DefaultMutableTreeNode t = new DefaultMutableTreeNode(kvp);
+        //将sttSectionList中的所有数据都添加到树节点中
+        for(STTsection stTsection : sttSectionList){
+            t.add(stTsection.getJTreeNode(modus));
+        }
+        return t;
+    }
+
+    /**
+     * sttsection获取方法
+     * @return
+     */
+    public List<STTsection> getSttSectionList() {
+        return sttSectionList;
+    }
+
+    static TableHeader<STTsection,STTsection> bulidSttTableHeader(){
+        //TODO
+        return new TableHeaderBuilder<STTsection, STTsection>().
+                addRequiredBaseColumn("system_time",STTsection::getSystem_time_String, String.class).
+                build();
+    }
+
+    /**
+     * 获取表模型
+     * @return
+     */
+    public TableModel getTableModel(){
+        //创建表模型
+        FlexTableModel<STTsection, STTsection> tableModel = new FlexTableModel<>(bulidSttTableHeader());
+        //将sttSectionList的数据添加到表模型中
+        for (STTsection stTsection : sttSectionList) {
+            if(stTsection != null) {
+                tableModel.addData(stTsection, List.of(stTsection));
+            }
+        }
+        //模型处理
+        tableModel.process();
+        return tableModel;
+    }
+
+//    static TableHeader<STTsection, STTsection>  buildSdtTableHeader() {
+//        return new TableHeaderBuilder<STTsection, STTsection>().
+//                addRequiredBaseColumn("system_time", STTsection::getSystem_time_String, String.class).
+//                addRequiredBaseColumn("GPS_UTC_offset", STTsection::getGPS_UTC_offset_BigInteger, BigInteger.class).
+//                build();
+//    }
+
+    public BigInteger get_offset(){
+        try{
+            return sttSectionList.getFirst().getGPS_UTC_offset_BigInteger();
+        }catch (RuntimeException e){
+            return new BigInteger("0");
+        }
+    }
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/STTsection.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/STTsection.java
new file mode 100644
index 0000000..32e6b86
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/STTsection.java
@@ -0,0 +1,211 @@
+package nl.digitalekabeltelevisie.data.mpeg.psi;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.data.mpeg.PID;
+import nl.digitalekabeltelevisie.data.mpeg.PSI;
+import nl.digitalekabeltelevisie.data.mpeg.PsiSectionData;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.DescriptorFactory;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.LocalTimeOffsetDescriptor;
+import nl.digitalekabeltelevisie.util.Utils;
+import nl.digitalekabeltelevisie.util.tablemodel.FlexTableModel;
+
+import javax.swing.table.TableModel;
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.math.BigInteger;
+import java.time.Duration;
+import java.time.Instant;
+import java.time.LocalDateTime;
+import java.time.ZoneOffset;
+import java.time.format.DateTimeFormatter;
+import java.util.ArrayList;
+import java.util.List;
+
+import static java.util.Arrays.copyOfRange;
+import static nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor.findGenericDescriptorsInList;
+
+/**
+ * STT相关函数
+ * author: dinghang.men
+ */
+
+public class STTsection extends TableSection{
+
+    private final int section_length;
+    private final byte[] protocol_version;  //协议类型
+
+    private final byte[] system_time;   //系统时间
+
+    private final byte[] GPS_UTC_offset;  //时间偏移
+
+    private final byte[] daylight_saving;  //日光节约时间控制字节
+
+    private final List<Descriptor> descriptorList;   //描述
+
+    /**
+     * 构造函数，给成员变量赋值
+     * @param raw_data
+     * @param parent
+     */
+    public STTsection(final PsiSectionData raw_data, final PID parent){
+        super(raw_data,parent);
+        //由ATSC  STT标准表计算
+        //section_length = Utils.getInt(raw_data.getData(),1,2,Utils.MASK_12BITS);
+        section_length = getSectionLength();
+
+        protocol_version = copyOfRange(raw_data.getData(), 8,9);
+        system_time = copyOfRange(raw_data.getData(), 9,13);
+        GPS_UTC_offset = copyOfRange(raw_data.getData(), 13,14);
+        daylight_saving = copyOfRange(raw_data.getData(), 14,16);
+
+        descriptorList = DescriptorFactory.buildDescriptorList(raw_data.getData(),16,section_length-13-4,this);
+    }
+
+    /**
+     *
+     * @return
+     */
+//    @Override
+//    public String toString(){
+//        final StringBuilder b = new StringBuilder("STTsection system_time=");
+//        b.append(Utils.toHexString(system_time))
+//                .append(", system_time_string=")
+//                .append(Utils.getUTCFormattedString(system_time))
+//                .append(",length=").append(getSectionLength())
+//                .append(",");
+//        for (Descriptor descriptor : descriptorList) {
+//            b.append(descriptor).append(", ");
+//        }
+//        return b.toString();
+//    }
+
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(final int modus) {
+        final DefaultMutableTreeNode t = super.getJTreeNode(modus);
+        KVP kvp = (KVP)t.getUserObject();
+        kvp.setTableSource(this::getTableModel);
+        t.add(new DefaultMutableTreeNode(new KVP("protocol_version",getProtocol_version_int(),null)));
+        t.add(new DefaultMutableTreeNode(new KVP("system_time",getSystem_time_BigInteger(),
+                convertGpsTimeToUtc(Utils.getBigInteger(system_time,0,4),
+                        Utils.getBigInteger(GPS_UTC_offset,0,1)
+))));
+        t.add(new DefaultMutableTreeNode(new KVP("GPS_UTC_offset",getGPS_UTC_offset_BigInteger(),null)));
+        t.add(new DefaultMutableTreeNode(new KVP("daylight_saving",daylight_saving,explain_daylight_saving(daylight_saving))));
+
+        Utils.addListJTree(t,descriptorList,modus,"descriptors");
+        return t;
+    }
+
+
+    public TableModel getTableModel(){
+        FlexTableModel<STTsection, STTsection> tableModel =  new FlexTableModel<>(STT.bulidSttTableHeader());
+
+        List<STTsection> list = new ArrayList<>();
+        list.add(this);
+        tableModel.addData(this, list);
+
+        tableModel.process();
+        return tableModel;
+    }
+
+
+
+
+//    public static String convertGpsTimeToUtc(byte[] system_time, byte[] GPS_UTC_offset) {
+//
+//        BigInteger seconds = Utils.getBigInteger(system_time,0,4);
+//        BigInteger offset = Utils.getBigInteger(GPS_UTC_offset,0,1);
+//        Instant GPS_EPOCH_START = LocalDateTime.of(1980, 1, 6, 0, 0, 0).toInstant(ZoneOffset.UTC);
+//        // 使用 GPS 初始时间加上给定的秒数，创建一个新的时间点
+//        Instant targetTime = GPS_EPOCH_START.plus(Duration.ofSeconds(seconds.longValue())).minus(Duration.ofSeconds(offset.longValue()));
+//
+//        // 格式化输出时间
+//        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").withZone(ZoneOffset.UTC);
+//        return dateTimeFormatter.format(targetTime);
+//    }
+
+    public static String convertGpsTimeToUtc(BigInteger system_time, BigInteger GPS_UTC_offset) {
+
+        Instant GPS_EPOCH_START = LocalDateTime.of(1980, 1, 6, 0, 0, 0).toInstant(ZoneOffset.UTC);
+        // 使用 GPS 初始时间加上给定的秒数，创建一个新的时间点
+        Instant targetTime = GPS_EPOCH_START.plus(Duration.ofSeconds(system_time.longValue())).minus(Duration.ofSeconds(GPS_UTC_offset.longValue()));
+
+        // 格式化输出时间
+        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").withZone(ZoneOffset.UTC);
+        return dateTimeFormatter.format(targetTime);
+    }
+
+
+
+    public static String explain_daylight_saving(byte[] daylight_saving){
+        int DS_status;
+        int DS_day_of_month;
+        int DS_hour;
+        DS_status = Utils.getBitsFromByteArray(daylight_saving,0,1);
+        DS_day_of_month  = Utils.getBitsFromByteArray(daylight_saving,3,5);
+        DS_hour = Utils.getBitsFromByteArray(daylight_saving,8,8);
+        StringBuilder s = new StringBuilder();
+        s.append("DS_status=").append(DS_status);
+        if(DS_status == 0){
+            s.append("(Not in daylight saving time)");
+        }else{
+            s.append("(In daylight saving time)");
+        }
+        s.append(" , DS_day_of_month=").append(DS_day_of_month).append(" , DS_hour=").append(DS_hour);
+        return s.toString();
+    }
+
+
+    public byte[] getSystem_time(){
+        return system_time;
+    }
+
+    public String getSystem_time_String(){
+
+        Instant GPS_EPOCH_START = LocalDateTime.of(1980, 1, 6, 0, 0, 0).toInstant(ZoneOffset.UTC);
+        // 使用 GPS 初始时间加上给定的秒数，创建一个新的时间点
+        Instant targetTime = GPS_EPOCH_START.plus(Duration.ofSeconds((this.getSystem_time_BigInteger()).longValue()))
+                .minus(Duration.ofSeconds((this.getGPS_UTC_offset_BigInteger()).longValue()));
+
+        // 格式化输出时间
+        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").withZone(ZoneOffset.UTC);
+        return dateTimeFormatter.format(targetTime);
+    }
+
+    public BigInteger getSystem_time_BigInteger(){
+        return Utils.getBigInteger(system_time,0,4);
+    }
+
+
+    public int getSection_length() {
+        return section_length;
+    }
+
+    public byte[] getProtocol_version() {
+        return protocol_version;
+    }
+
+    public int getProtocol_version_int(){
+        return Utils.getInt(protocol_version,0,1,Utils.MASK_8BITS);
+    }
+
+    public byte[] getGPS_UTC_offset() {
+        return GPS_UTC_offset;
+    }
+
+    public BigInteger getGPS_UTC_offset_BigInteger(){
+        return Utils.getBigInteger(GPS_UTC_offset,0,1);
+    }
+
+    public byte[] getDaylight_saving() {
+        return daylight_saving;
+    }
+
+    /**
+     *
+     * @return
+     */
+    public List<Descriptor> getDescriptorList(){
+        return descriptorList;
+    }
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/TVCT.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/TVCT.java
new file mode 100644
index 0000000..b5884f2
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/TVCT.java
@@ -0,0 +1,86 @@
+package nl.digitalekabeltelevisie.data.mpeg.psi;
+
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.data.mpeg.PSI;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.LocalTimeOffsetDescriptor;
+import nl.digitalekabeltelevisie.util.tablemodel.FlexTableModel;
+import nl.digitalekabeltelevisie.util.tablemodel.TableHeader;
+import nl.digitalekabeltelevisie.util.tablemodel.TableHeaderBuilder;
+import nl.digitalekabeltelevisie.data.mpeg.psi.TVCTsection.VirtualChannel;
+
+import javax.swing.table.TableModel;
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.util.ArrayList;
+import java.util.List;
+
+import static nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor.findGenericDescriptorsInList;
+
+public class TVCT extends AbstractPSITabel{
+
+    private final List<TVCTsection> tvctSectionList = new ArrayList<>();
+
+    public TVCT(final PSI parentPSI){
+        super(parentPSI);
+    }
+
+    public void update(final TVCTsection section){
+        if(!tvctSectionList.contains(section)){
+            tvctSectionList.add(section);
+        }
+    }
+
+    static TableHeader<TVCTsection, VirtualChannel> buildTVCTTableHeader() {
+        return new TableHeaderBuilder<TVCTsection,VirtualChannel>()
+                .addOptionalRowColumn("Source_id",VirtualChannel::getSource_id,Integer.class)
+                .addOptionalRowColumn("Major_channel_number",VirtualChannel::getMajor_channel_number,Integer.class)
+                .addOptionalRowColumn("Minor_channel_number",VirtualChannel::getMinor_channel_number, Integer.class)
+                .addOptionalRowColumn("Modulation_mode",VirtualChannel::getModulation_mode,Integer.class)
+                .addOptionalRowColumn("Program_number",VirtualChannel::getProgram_number, Integer.class)
+                .addOptionalRowColumn("ETM_location",VirtualChannel::getETM_location, Integer.class)
+                .addOptionalRowColumn("Program_number",VirtualChannel::getAccess_controlled, Integer.class)
+                .addOptionalRowColumn("Hidden",VirtualChannel::getHidden, Integer.class)
+                .addOptionalRowColumn("Hide_guide",VirtualChannel::getHide_guide, Integer.class)
+                .addOptionalRowColumn("Service_type",VirtualChannel::getService_type, Integer.class)
+                .build();
+    }
+
+
+    @Override
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        if(!tvctSectionList.isEmpty()){
+            int tableId = getTvctSectionList().getFirst().getTableId();
+        }
+        KVP kvp = new KVP("VCT (TVCT/CVCT)");
+        if(!tvctSectionList.isEmpty()){
+            //设置Table格式
+            kvp.setTableSource(this::getTableModel);
+        }
+        final DefaultMutableTreeNode t = new DefaultMutableTreeNode(kvp);
+        //将sttSectionList中的所有数据都添加到树节点中
+        for(TVCTsection tvcTsection : tvctSectionList){
+            t.add(tvcTsection.getJTreeNode(modus));
+        }
+        return t;
+    }
+
+    public TableModel getTableModel(){
+        //创建表模型
+        FlexTableModel<TVCTsection, VirtualChannel> tableModel = new FlexTableModel<>(buildTVCTTableHeader());
+        //将sttSectionList的数据添加到表模型中
+        for (TVCTsection tvcTsection : tvctSectionList) {
+            if(tvcTsection != null) {
+                tableModel.addData(tvcTsection, tvcTsection.getVirtualChannelList());
+//                tableModel.addData(tvcTsection, findGenericDescriptorsInList
+//                        (tvcTsection.getAdditional_descriptorList(),Descriptor.class));
+            }
+        }
+        //模型处理
+        tableModel.process();
+        return tableModel;
+    }
+
+    public List<TVCTsection> getTvctSectionList() {
+        return tvctSectionList;
+    }
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/TVCTsection.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/TVCTsection.java
new file mode 100644
index 0000000..942b975
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/TVCTsection.java
@@ -0,0 +1,527 @@
+package nl.digitalekabeltelevisie.data.mpeg.psi;
+
+import com.sun.source.tree.Tree;
+import nl.digitalekabeltelevisie.controller.KVP;
+import nl.digitalekabeltelevisie.controller.TreeNode;
+import nl.digitalekabeltelevisie.data.mpeg.PID;
+import nl.digitalekabeltelevisie.data.mpeg.PsiSectionData;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.DescriptorFactory;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.LocalTimeOffsetDescriptor;
+import nl.digitalekabeltelevisie.util.Utils;
+import nl.digitalekabeltelevisie.util.tablemodel.FlexTableModel;
+
+import javax.swing.table.TableModel;
+import javax.swing.tree.DefaultMutableTreeNode;
+import java.math.BigInteger;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static java.util.Arrays.copyOfRange;
+import static nl.digitalekabeltelevisie.data.mpeg.descriptors.Descriptor.findGenericDescriptorsInList;
+
+public class TVCTsection extends TableSection{
+    private int protocol_version;
+    //An 8-bit unsigned integer field,the only valid value for protocol_version is zero.
+
+    private int num_channels_in_section;
+    //This 8 bit field specifies the number of virtual channels in this VCT
+    //section. The number is limited by the section length.
+    //这个8位字段指定了这个VCT段中的虚拟通道的数量。数量受部分长度的限制。
+
+    private List<VirtualChannel> VirtualChannelList;
+
+    public class VirtualChannel implements TreeNode{
+        private  byte[] short_name;
+        //The name of the virtual channel, represented as a sequence of one to seven 16-bit
+        //code values interpreted in accordance with the UTF-16 representation of Unicode character
+        //data. If the length of the name requires fewer than seven 16-bit code values, this field shall be
+        //padded out to seven 16-bit code values using the Unicode NUL character (0x0000)
+        //虚拟通道的名称，表示为1到7个16位代码值的序列，这些代码值按照Unicode字符数据的UTF-16表示进行解释。
+        // 如果名称的长度需要少于7个16位代码值，则该字段将使用Unicode NUL字符(0x0000)填充为7个16位代码值。
+
+        private int major_channel_number;
+        //10bits
+
+        private  int minor_channel_number;
+        //10bits
+
+        private  int modulation_mode;
+        //8bits
+
+        private  BigInteger carrier_frequency;
+        //32bits
+
+        private  int channel_TSID;
+        //16bits
+
+        private  int program_number;
+        //16bits
+
+        private  int ETM_location;
+        //2bits
+
+        private  int access_controlled;
+        //1bits
+
+        private  int hidden;
+        //1bit
+
+        private  int hide_guide;
+        //1bits
+
+        private  int service_type;
+        //6bits
+
+        private  int source_id;
+        //16bit
+
+        private int descriptors_length;
+        //10bits
+
+        private  List<Descriptor> descriptorList;
+
+
+        @Override
+        public DefaultMutableTreeNode getJTreeNode(int modus) {
+            final DefaultMutableTreeNode t = new DefaultMutableTreeNode(new KVP("virtual_channel"));
+            t.add(new DefaultMutableTreeNode(new KVP("short_name",short_name,explain_short_name(short_name))));
+            t.add(new DefaultMutableTreeNode(new KVP("major_channel_number",major_channel_number,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("minor_channel_number",minor_channel_number,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("modulation_mode",modulation_mode,explain_modulation_mode(modulation_mode))));
+            t.add(new DefaultMutableTreeNode(new KVP("carrier_frequency",carrier_frequency,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("channel_TSID",channel_TSID,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("program_number",program_number,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("ETM_location",ETM_location,explain_ETM_location(ETM_location))));
+            t.add(new DefaultMutableTreeNode(new KVP("access_controlled",access_controlled,explain_access_controlled(access_controlled))));
+            t.add(new DefaultMutableTreeNode(new KVP("hidden",hidden,explain_hidden(hidden))));
+            t.add(new DefaultMutableTreeNode(new KVP("hide_guide",hide_guide,explain_hide_guide(hide_guide))));
+            t.add(new DefaultMutableTreeNode(new KVP("service_type",service_type,explain_service_type(service_type))));
+            t.add(new DefaultMutableTreeNode(new KVP("source_id",source_id,null)));
+            t.add(new DefaultMutableTreeNode(new KVP("descriptors_length",descriptors_length,null)));
+            Utils.addListJTree(t,descriptorList,modus,"VirtualChannel descriptors");
+            return t;
+        }
+
+        public byte[] getShort_name() {
+            return short_name;
+        }
+
+        public void setShort_name(byte[] short_name) {
+            this.short_name = short_name;
+        }
+
+        public int getMajor_channel_number() {
+            return major_channel_number;
+        }
+
+        public void setMajor_channel_number(int major_channel_number) {
+            this.major_channel_number = major_channel_number;
+        }
+
+        public int getMinor_channel_number() {
+            return minor_channel_number;
+        }
+
+        public void setMinor_channel_number(int minor_channel_number) {
+            this.minor_channel_number = minor_channel_number;
+        }
+
+        public int getModulation_mode() {
+            return modulation_mode;
+        }
+
+        public void setModulation_mode(int modulation_mode) {
+            this.modulation_mode = modulation_mode;
+        }
+
+        public BigInteger getCarrier_frequency() {
+            return carrier_frequency;
+        }
+
+        public void setCarrier_frequency(BigInteger carrier_frequency) {
+            this.carrier_frequency = carrier_frequency;
+        }
+
+        public int getChannel_TSID() {
+            return channel_TSID;
+        }
+
+        public void setChannel_TSID(int channel_TSID) {
+            this.channel_TSID = channel_TSID;
+        }
+
+        public int getProgram_number() {
+            return program_number;
+        }
+
+        public void setProgram_number(int program_number) {
+            this.program_number = program_number;
+        }
+
+        public int getETM_location() {
+            return ETM_location;
+        }
+
+        public void setETM_location(int ETM_location) {
+            this.ETM_location = ETM_location;
+        }
+
+        public int getAccess_controlled() {
+            return access_controlled;
+        }
+
+        public void setAccess_controlled(int access_controlled) {
+            this.access_controlled = access_controlled;
+        }
+
+        public int getHidden() {
+            return hidden;
+        }
+
+        public void setHidden(int hidden) {
+            this.hidden = hidden;
+        }
+
+        public int getHide_guide() {
+            return hide_guide;
+        }
+
+        public void setHide_guide(int hide_guide) {
+            this.hide_guide = hide_guide;
+        }
+
+        public int getService_type() {
+            return service_type;
+        }
+
+        public void setService_type(int service_type) {
+            this.service_type = service_type;
+        }
+
+        public int getSource_id() {
+            return source_id;
+        }
+
+        public void setSource_id(int source_id) {
+            this.source_id = source_id;
+        }
+
+        public int getDescriptors_length() {
+            return descriptors_length;
+        }
+
+        public void setDescriptors_length(int descriptors_length) {
+            this.descriptors_length = descriptors_length;
+        }
+
+        public List<Descriptor> getDescriptorList() {
+            return descriptorList;
+        }
+
+        public void setDescriptorList(List<Descriptor> descriptorList) {
+            this.descriptorList = descriptorList;
+        }
+    }
+
+    private int additional_descriptors_length;
+
+    private  List<Descriptor> additional_descriptorList;
+
+    public int getProtocol_version() {
+        return protocol_version;
+    }
+
+    public void setProtocol_version(int protocol_version) {
+        this.protocol_version = protocol_version;
+    }
+
+    public int getNum_channels_in_section() {
+        return num_channels_in_section;
+    }
+
+    public void setNum_channels_in_section(int num_channels_in_section) {
+        this.num_channels_in_section = num_channels_in_section;
+    }
+
+    public List<VirtualChannel> getVirtualChannelList() {
+        return VirtualChannelList;
+    }
+
+    public void setVirtualChannelList(List<VirtualChannel> virtualChannelList) {
+        VirtualChannelList = virtualChannelList;
+    }
+
+    public int getAdditional_descriptors_length() {
+        return additional_descriptors_length;
+    }
+
+    public void setAdditional_descriptors_length(int additional_descriptors_length) {
+        this.additional_descriptors_length = additional_descriptors_length;
+    }
+
+    public List<Descriptor> getAdditional_descriptorList() {
+        return additional_descriptorList;
+    }
+
+    public void setAdditional_descriptorList(List<Descriptor> additional_descriptorList) {
+        this.additional_descriptorList = additional_descriptorList;
+    }
+
+//    private List<VirtualChannel> bulidVirtualChannelList(final byte[] raw_data, int offset, final int num_channels_in_section){
+//        final ArrayList<VirtualChannel> r = new ArrayList<>();
+//        //int current_offset = offset;
+//        for (int i = 0; i < num_channels_in_section; i++) {
+//            VirtualChannel vc = new VirtualChannel();
+//            vc.setShort_name(copyOfRange(raw_data,offset,offset+14));
+//            offset += 14;
+//            vc.setMajor_channel_number(Utils.getInt(raw_data,offset,3, 0x003FF0));//24位中的5-14位
+//            vc.setMinor_channel_number(Utils.getInt(raw_data,offset,3,0xFFC000));//24位中的15-24位
+//            offset += 3;
+//            vc.setModulation_mode(Utils.getInt(raw_data,offset,1,Utils.MASK_8BITS));
+//            offset += 1;
+//            vc.setCarrier_frequency(Utils.getBigInteger(raw_data,offset,4));
+//            offset += 4;
+//            vc.setChannel_TSID(Utils.getInt(raw_data,offset,2,Utils.MASK_16BITS));
+//            offset += 2;
+//            vc.setProgram_number(Utils.getInt(raw_data,offset,2,Utils.MASK_16BITS));
+//            offset += 2;
+//            //byte temp_8bits = Utils.getBytes(raw_data,offset,1)[0];
+//            vc.setETM_location(Utils.getInt(raw_data,offset,1,Utils.MASK_2BITS));
+//            vc.setAccess_controlled(Utils.getInt(raw_data,offset,1,0x04));
+//            vc.setHidden(Utils.getInt(raw_data,offset,1,0x08));
+//            vc.setHide_guide(Utils.getInt(raw_data,offset,1,0x40));
+//            offset += 1;
+//            vc.setService_type((Utils.getBytes(raw_data,offset,1)));
+//            offset += 1;
+//            vc.setSource_id(Utils.getInt(raw_data,offset,2,Utils.MASK_16BITS));
+//            offset += 2;
+//            vc.setDescriptors_length(Utils.getInt(raw_data,offset,2,Utils.MASK_10BITS));
+//            offset += 2;
+//            vc.setDescriptorList(DescriptorFactory.buildDescriptorList(raw_data,offset,vc.getDescriptors_length(),this));
+//            r.add(vc);
+//            offset += vc.descriptors_length;
+//
+//        }
+//        //additional_descriptors
+//
+//        return r;
+//    }
+
+
+    public TVCTsection(final PsiSectionData raw_data, final PID parent){
+        super(raw_data, parent);
+        protocol_version = Utils.getInt(raw_data.getData(),8,1,Utils.MASK_8BITS);
+
+        num_channels_in_section = Utils.getInt(raw_data.getData(),9,1,Utils.MASK_8BITS);
+
+
+        int offset = 10;
+
+        //VirtualChannelList = bulidVirtualChannelList(raw_data.getData(), offset ,num_channels_in_section);
+
+        VirtualChannelList = new ArrayList<>();
+
+        //final ArrayList<VirtualChannel> r = new ArrayList<>();
+
+        for (int i = 0; i < num_channels_in_section; i++) {
+            VirtualChannel vc = new VirtualChannel();
+            vc.setShort_name(copyOfRange(raw_data.getData(),offset,offset+14));
+            offset += 14;
+
+            byte[]  temp = copyOfRange(raw_data.getData(),offset,offset+3);
+            //vc.setMajor_channel_number(Utils.getInt(raw_data.getData(),offset,3, 0x003FF0));//24位中的5-14位
+            vc.setMajor_channel_number(Utils.getBitsFromByteArray(temp,4,10));
+            //vc.setMinor_channel_number(Utils.getInt(raw_data.getData(),offset,3,0xFFC000));//24位中的15-24位
+            vc.setMinor_channel_number(Utils.getBitsFromByteArray(temp,14,10));
+
+            offset += 3;
+            vc.setModulation_mode(Utils.getInt(raw_data.getData(),offset,1,Utils.MASK_8BITS));
+            offset += 1;
+            vc.setCarrier_frequency(Utils.getBigInteger(raw_data.getData(),offset,4));
+            offset += 4;
+            vc.setChannel_TSID(Utils.getInt(raw_data.getData(),offset,2,Utils.MASK_16BITS));
+            offset += 2;
+            vc.setProgram_number(Utils.getInt(raw_data.getData(),offset,2,Utils.MASK_16BITS));
+            offset += 2;
+            //byte temp_8bits = Utils.getBytes(raw_data,offset,1)[0];
+            vc.setETM_location(Utils.getInt(raw_data.getData(),offset,1,Utils.MASK_2BITS));
+
+            //vc.setAccess_controlled(Utils.getInt(raw_data.getData(),offset,1,0x04));
+            byte b = copyOfRange(raw_data.getData(),offset,offset+1)[0];
+            vc.setAccess_controlled(Utils.getBit(b,3));
+
+            //vc.setHidden(Utils.getInt(raw_data.getData(),offset,1,0x08));
+            vc.setHidden(Utils.getBit(b,4));
+
+            //vc.setHide_guide(Utils.getInt(raw_data.getData(),offset,1,0x40));
+            vc.setHide_guide(Utils.getBit(b,7));
+
+            offset += 1;
+            vc.setService_type((Utils.getInt(raw_data.getData(),offset,1,Utils.MASK_6BITS)));
+            offset += 1;
+            vc.setSource_id(Utils.getInt(raw_data.getData(),offset,2,Utils.MASK_16BITS));
+            offset += 2;
+            vc.setDescriptors_length(Utils.getInt(raw_data.getData(),offset,2,Utils.MASK_10BITS));
+            offset += 2;
+            vc.setDescriptorList(DescriptorFactory.buildDescriptorList(raw_data.getData(),offset,vc.getDescriptors_length(),this));
+            VirtualChannelList.add(vc);
+            offset += vc.descriptors_length;
+        }
+        additional_descriptors_length = Utils.getInt(raw_data.getData(),offset,2,Utils.MASK_10BITS);
+        offset += 2;
+        additional_descriptorList = DescriptorFactory.buildDescriptorList(raw_data.getData(),offset,additional_descriptors_length,this);
+    }
+
+    public DefaultMutableTreeNode getJTreeNode(int modus) {
+        final DefaultMutableTreeNode t = super.getJTreeNode(modus);
+        ((KVP) t.getUserObject()).setTableSource(this::getTableModel);
+        t.add(new DefaultMutableTreeNode(new KVP("protocol_version",protocol_version,null)));
+        t.add(new DefaultMutableTreeNode(new KVP("num_channels_in_section",num_channels_in_section,null)));
+        Utils.addListJTree(t,VirtualChannelList,modus,"VirtualChannelList");
+        t.add(new DefaultMutableTreeNode(new KVP("additional_descriptors_length",additional_descriptors_length,null)));
+        Utils.addListJTree(t,additional_descriptorList,modus,"additional_descriptorList");
+        return t;
+    }
+
+    public TableModel getTableModel() {
+        FlexTableModel<TVCTsection, VirtualChannel> tableModel =  new FlexTableModel<>(TVCT.buildTVCTTableHeader());
+        tableModel.addData(this,this.getVirtualChannelList());
+//        tableModel.addData(this,findGenericDescriptorsInList(getAdditional_descriptorList(), Descriptor.class));
+        tableModel.process();
+        return tableModel;
+    }
+
+    @Override
+    protected String getTableIdExtensionLabel() {
+        return "transport_stream_id";
+    }
+
+    public static String explain_short_name(byte[] short_name){
+        Charset utf16 = Charset.forName("UTF-16");
+
+        ByteBuffer byteBuffer = ByteBuffer.wrap(short_name);
+        CharBuffer charBuffer = utf16.decode(byteBuffer);
+
+        String decodedString = charBuffer.toString();
+//        StringBuilder s = new StringBuilder();
+//        s.append("Decoded String: ");
+        return decodedString;
+    }
+
+    public static String explain_modulation_mode(int modulation_mode){
+        StringBuilder s = new StringBuilder();
+        if(modulation_mode == 0){
+            s.append("Reserved");
+        }
+        if(modulation_mode == 1){
+            s.append("Analog");
+        }
+        if(modulation_mode == 2){
+            s.append("SCTE_mode_1, 5.057 Msps, 64-QAM");
+        }
+        if(modulation_mode == 3){
+            s.append("SCTE_mode_2, 5.361 Msps, 256-QAM");
+        }
+        if(modulation_mode == 4){
+            s.append("ATSC (8 VSB)");
+        }
+        if(modulation_mode == 5){
+            s.append("ATSC (16 VSB)");
+        }
+        if(modulation_mode >= 6 && modulation_mode <= 127){
+            s.append("Reserved for future use by ATSC");
+        }
+        if(modulation_mode >= 128 && modulation_mode <= 255){
+            s.append("User Private");
+        }
+        return s.toString();
+    }
+
+    public static String explain_ETM_location(int ETM_location){
+        StringBuilder s = new StringBuilder();
+            if(ETM_location == 0){
+                s.append("No ETM");
+            }
+            if(ETM_location == 1){
+                s.append("ETM located in the PTC carrying this PSIP");
+            }
+            if(ETM_location == 2){
+                s.append("ETM located in the PTC specified by the \n" +
+                        "channel_TSID");
+            }
+            if(ETM_location == 3){
+                s.append("[Reserved for future ATSC use]");
+            }
+        return s.toString();
+    }
+
+    public static String explain_access_controlled(int access_controlled){
+        StringBuilder s = new StringBuilder();
+        if(access_controlled == 0){
+            s.append("events associated with \n" +
+                    "this virtual channel may be access controlled");
+        }
+        if(access_controlled == 1){
+            s.append("event access is not \n" +
+                    "restricted");
+        }
+        return s.toString();
+    }
+
+    public static String explain_hidden(int hidden){
+        StringBuilder s = new StringBuilder();
+        if(hidden == 1){
+            s.append(" the virtual channel is not accessed by \n" +
+                    "the user by direct entry of the virtual channel number.");
+        }else{
+            s.append(" the virtual channel is accessed by \n" +
+                    "the user by direct entry of the virtual channel number.");
+        }
+        return s.toString();
+    }
+
+    public static String explain_hide_guide(int hide_guide){
+        StringBuilder s = new StringBuilder();
+        if(hide_guide == 0){
+            s.append("the virtual channel and its events may appear in EPG displays.");
+        }else{
+            s.append(" test signals and services accessible \n" +
+                    "through application-level pointers.");
+        }
+        return s.toString();
+    }
+
+    public static String explain_service_type(int service_type){
+
+        StringBuilder s = new StringBuilder();
+        if(service_type == 0){
+            s.append("Reserved");
+        }
+        if(service_type == 1){
+            s.append("Analog Television ");
+        }
+        if(service_type == 2){
+            s.append("ATSC Digital Television ");
+        }
+        if(service_type == 3){
+            s.append("ATSC Audio ");
+        }
+        if(service_type == 4){
+            s.append("ATSC Data Only Service ");
+        }
+        if(service_type == 5){
+            s.append("ATSC Software Download Service ");
+        }
+        if(service_type >= 6 && service_type <= 63){
+            s.append("Reserved");
+        }
+        return s.toString();
+    }
+
+
+}
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/TableSection.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/TableSection.java
index 0f7c259..a914b5f 100644
--- a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/TableSection.java
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/TableSection.java
@@ -267,7 +267,7 @@ public class TableSection implements TreeNode{
 		case 0xBD: return "user defined / M7 Fastscan Services Table (FST) ";
 		case 0xBE: return "user defined / M7 Operator Network Table (ONT) ";
 
-
+		// modify dinghang.men
 		// https://fossies.org/linux/MediaInfo_CLI/MediaInfoLib/Source/MediaInfo/Multiple/File_Mpeg_Psi.cpp
 		case 0xC0 : return "user defined / ATSC - Program Information Message";
         case 0xC1 : return "user defined / ATSC - Program Name Message";
@@ -276,13 +276,20 @@ public class TableSection implements TreeNode{
         case 0xC4 : return "user defined / ATSC/SCTE - Short Form Virtual Channel Table (S-VCT)";
         case 0xC5 : return "user defined / ATSC/SCTE - System Time Table (STT)";
         case 0xC6 : return "user defined / ATSC/SCTE - Subtitle Message (SCTE-27)";
-        case 0xC7 : return "user defined / ATSC - Master Guide Table (MGT)";
-        case 0xC8 : return "user defined / ATSC - Terrestrial Virtual Channel Table (TVCT)";
-        case 0xC9 : return "user defined / ATSC - Cable Virtual Channel Table (CVCT) / Long-form Virtual Channel Table (L-VCT)";
-        case 0xCA : return "user defined / ATSC - Rating Region Table (RRT)";
-        case 0xCB : return "user defined / ATSC - Event Information Table (EIT)";
-        case 0xCC : return "user defined / ATSC - Extended Text Table (ETT)";
-        case 0xCD : return "user defined / ATSC - System Time Table (STT)";
+//        case 0xC7 : return "user defined / ATSC - Master Guide Table (MGT)";
+        case 0xC7 : return "ATSC - Master Guide Table (MGT)";
+//        case 0xC8 : return "user defined / ATSC - Terrestrial Virtual Channel Table (TVCT)";
+        case 0xC8 : return "ATSC - Terrestrial Virtual Channel Table (TVCT)";
+//        case 0xC9 : return "user defined / ATSC - Cable Virtual Channel Table (CVCT) / Long-form Virtual Channel Table (L-VCT)";
+        case 0xC9 : return "ATSC - Cable Virtual Channel Table (CVCT)";
+//        case 0xCA : return "user defined / ATSC - Rating Region Table (RRT)";
+        case 0xCA : return "ATSC - Rating Region Table (RRT)";
+//        case 0xCB : return "user defined / ATSC - Event Information Table (EIT)";
+        case 0xCB : return "ATSC - Event Information Table (EIT)";
+//        case 0xCC : return "user defined / ATSC - Extended Text Table (ETT)";
+        case 0xCC : return "ATSC - Extended Text Table (ETT)";
+//        case 0xCD : return "user defined / ATSC - System Time Table (STT)";
+        case 0xCD : return "ATSC - System Time Table (STT)";
         case 0xCE : return "user defined / ATSC - Data Event Table (DET)";
         case 0xCF : return "user defined / ATSC - Data Service Table (DST)";
         case 0xD0 : return "user defined / ATSC - Program Identifier Table (PIT)";
diff --git a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/handler/GeneralPsiTableHandler.java b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/handler/GeneralPsiTableHandler.java
index 7557b18..c5a7ba1 100644
--- a/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/handler/GeneralPsiTableHandler.java
+++ b/src/main/java/nl/digitalekabeltelevisie/data/mpeg/psi/handler/GeneralPsiTableHandler.java
@@ -65,6 +65,7 @@ public class GeneralPsiTableHandler extends GeneralPidHandler {
 	private TDT tdt;
 	private TOT tot;
 	private SIT sit;
+
 	
 	// private INT int_table; // INT and DFIT use same tableID, both not supported here
 	private UNTs unt_table;
@@ -75,7 +76,11 @@ public class GeneralPsiTableHandler extends GeneralPidHandler {
 	// private DFITs dfit_table;// INT and DFIT use same tableID, both not supported here
 	
 	private M7Fastscan m7fastscan;
+
+	//modify dinghang.men
+	private STT stt;
 	
+	private TVCT tvct;
 
 
 	@Override
@@ -98,6 +103,10 @@ public class GeneralPsiTableHandler extends GeneralPidHandler {
 		addToNodeIfNotNull(node, scte35_table, modus);
 		addToNodeIfNotNull(node, dsm_table, modus);
 		addToNodeIfNotNull(node, m7fastscan, modus);
+		//modify dinghang.men
+		addToNodeIfNotNull(node, stt, modus);
+		addToNodeIfNotNull(node, tvct, modus);
+
 		return node;
 	}
 
@@ -141,6 +150,8 @@ public class GeneralPsiTableHandler extends GeneralPidHandler {
 		}
 		try {
 			int tableID = section.getTableId();
+			//dinghang.men
+			System.out.println("tableid:"+tableID+"\n" );
 
 			if (tableID == 0x00) {
 				handlePAT(section);
@@ -180,6 +191,12 @@ public class GeneralPsiTableHandler extends GeneralPidHandler {
 			} else if (tableID == 0xFC) { // SCTE-35
 				handleSCTE35(section);
 			}
+			//modify dinghang.men
+			else if (tableID == 0xCD) {   //stt
+				handleSTT(section);
+			} else if (tableID == 0xC8) {
+				handleTVCT(section);
+			}
 		} catch (RuntimeException rte) {
 			logger.info(("Ignoring section with tableId:" + section.getTableId() + ", exception:" + rte.getMessage()));
 		}
@@ -334,6 +351,26 @@ public class GeneralPsiTableHandler extends GeneralPidHandler {
 		tot.update(s);
 	}
 
+	//modify dinghang.men
+	private void handleSTT(final TableSection section){
+		if(stt == null){
+			stt = new STT(getTransportStream().getPsi());
+		}
+		STTsection s = new STTsection(section.getRaw_data(), pid);
+		copyMetaData(section,s);
+		stt.update(s);
+	}
+
+	//modify dinghang.men
+	private void handleTVCT(final TableSection section){
+		if(tvct == null){
+			tvct = new TVCT(getTransportStream().getPsi());
+		}
+		TVCTsection s = new TVCTsection(section.getRaw_data(), pid);
+		copyMetaData(section,s);
+		tvct.update(s);
+	}
+
 	private void handleFastScan(final TableSection section) {
 		if (m7fastscan == null) {
 			m7fastscan = new M7Fastscan(getTransportStream().getPsi());
diff --git a/src/main/java/nl/digitalekabeltelevisie/gui/EITATSCView.java b/src/main/java/nl/digitalekabeltelevisie/gui/EITATSCView.java
new file mode 100644
index 0000000..26b843e
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/gui/EITATSCView.java
@@ -0,0 +1,142 @@
+/**
+ *
+ *  http://www.digitalekabeltelevisie.nl/dvb_inspector
+ *
+ *  This code is Copyright 2009-2019 by Eric Berendsen (e_berendsen@digitalekabeltelevisie.nl)
+ *
+ *  This file is part of DVB Inspector.
+ *
+ *  DVB Inspector is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  DVB Inspector is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with DVB Inspector.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *  The author requests that he be notified of any application, applet, or
+ *  other binary that makes use of this code, but that's more out of curiosity
+ *  than anything and is not required.
+ *
+ */
+
+package nl.digitalekabeltelevisie.gui;
+
+import java.awt.*;
+import java.awt.event.*;
+
+import javax.swing.*;
+
+import nl.digitalekabeltelevisie.controller.ViewContext;
+import nl.digitalekabeltelevisie.data.mpeg.TransportStream;
+import nl.digitalekabeltelevisie.data.mpeg.psi.EIT;
+import nl.digitalekabeltelevisie.data.mpeg.psi.EITATSC;
+import nl.digitalekabeltelevisie.gui.utils.WrapLayout;
+
+
+/**
+ *
+ */
+public class EITATSCView extends JPanel implements TransportStreamView{
+
+    public EITATSCtableImage atscEpgPanel;
+
+    public EITableImage eitPanel;
+    private final JPanel toolbar = new JPanel(new WrapLayout(FlowLayout.LEFT));
+
+    /**
+     * @param transportStream
+     * @param viewContext
+     */
+    public EITATSCView(final TransportStream transportStream, final ViewContext viewContext) {
+        super(new BorderLayout());
+
+        atscEpgPanel = new EITATSCtableImage(transportStream,viewContext);
+
+        JScrollPane scrollGrid = new JScrollPane(atscEpgPanel);
+        scrollGrid.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
+        scrollGrid.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
+
+//			toolbar.add(Box.createHorizontalStrut(50)); // spacer
+			addZoomRadioButtons();
+//
+			add(toolbar,BorderLayout.PAGE_START);
+			add(scrollGrid,BorderLayout.CENTER);
+
+
+    }
+
+    private void createCopySaveButtonBar() {
+
+        ImageCopyAction copyAction = new ImageCopyAction(this, "Copy", eitPanel);
+        JButton copyButton = new JButton(copyAction);
+        KeyStroke copyKey = KeyStroke.getKeyStroke(KeyEvent.VK_C,Event.CTRL_MASK);
+        getInputMap(WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(copyKey, "copy");
+        getActionMap().put("copy", copyAction);
+        toolbar.add(copyButton);
+
+        ImageSaveAction saveAction = new ImageSaveAction(this, "Save As...",eitPanel);
+        JButton saveButton = new JButton(saveAction);
+        KeyStroke saveKey = KeyStroke.getKeyStroke(KeyEvent.VK_S,Event.CTRL_MASK);
+        getInputMap(WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(saveKey, "save");
+        getActionMap().put("save", saveAction);
+        toolbar.add(saveButton);
+    }
+
+    /**
+     *
+     */
+    private void addPfScheduleRadioButtons() {
+        JLabel typeLabel = new JLabel("Table:");
+        toolbar.add(typeLabel);
+
+        JRadioButton pfButton = new JRadioButton("Present/Following");
+        pfButton.addActionListener(e -> eitPanel.selectPresentFollowing());
+        JRadioButton scheduleButton = new JRadioButton("Schedule");
+        scheduleButton.addActionListener(e -> eitPanel.selectSchedule());
+        scheduleButton.setSelected(true);
+        ButtonGroup group = new ButtonGroup();
+        group.add(pfButton);
+        group.add(scheduleButton);
+
+        toolbar.add(pfButton);
+        toolbar.add(scheduleButton);
+    }
+
+    private void addZoomRadioButtons() {
+        JLabel typeLabel = new JLabel("Zoom:");
+        toolbar.add(typeLabel);
+        JRadioButton zoom1Button = new JRadioButton("1");
+        zoom1Button.addActionListener(e -> atscEpgPanel.setZoom(30*1000L));
+        JRadioButton zoom2Button = new JRadioButton("2");
+        zoom2Button.addActionListener(e -> atscEpgPanel.setZoom(15*1000L));
+        JRadioButton zoom3Button = new JRadioButton("3");
+        zoom3Button.addActionListener(e -> atscEpgPanel.setZoom(7500L));
+        zoom2Button.setSelected(true);
+        ButtonGroup group = new ButtonGroup();
+        group.add(zoom1Button);
+        group.add(zoom2Button);
+        group.add(zoom3Button);
+
+        toolbar.add(zoom1Button);
+        toolbar.add(zoom2Button);
+        toolbar.add(zoom3Button);
+    }
+
+    /* (non-Javadoc)
+     * @see nl.digitalekabeltelevisie.gui.TransportStreamView#setTransportStream(nl.digitalekabeltelevisie.data.mpeg.TransportStream, nl.digitalekabeltelevisie.controller.ViewContext)
+     */
+    public void setTransportStream(final TransportStream transportStream, final ViewContext viewContext) {
+
+                atscEpgPanel.setTransportStream(transportStream,viewContext);
+                validate();
+                repaint();
+
+    }
+}
+
diff --git a/src/main/java/nl/digitalekabeltelevisie/gui/EITATSCtableImage.java b/src/main/java/nl/digitalekabeltelevisie/gui/EITATSCtableImage.java
new file mode 100644
index 0000000..72f0a47
--- /dev/null
+++ b/src/main/java/nl/digitalekabeltelevisie/gui/EITATSCtableImage.java
@@ -0,0 +1,781 @@
+/**
+ *
+ *  http://www.digitalekabeltelevisie.nl/dvb_inspector
+ *
+ *
+ */
+
+package nl.digitalekabeltelevisie.gui;
+
+import static nl.digitalekabeltelevisie.util.Utils.getUTCCalender;
+import static nl.digitalekabeltelevisie.util.Utils.roundHourDown;
+import static nl.digitalekabeltelevisie.util.Utils.roundHourUp;
+
+import java.awt.*;
+import java.awt.event.ComponentEvent;
+import java.awt.event.ComponentListener;
+import java.awt.event.MouseEvent;
+import java.awt.image.BufferedImage;
+import java.math.BigInteger;
+import java.nio.charset.StandardCharsets;
+import java.text.SimpleDateFormat;
+import java.util.*;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import javax.swing.JPanel;
+import javax.swing.Scrollable;
+import javax.swing.SwingConstants;
+
+import nl.digitalekabeltelevisie.controller.ViewContext;
+import nl.digitalekabeltelevisie.data.mpeg.TransportStream;
+import nl.digitalekabeltelevisie.data.mpeg.descriptors.extension.atsc.MSSdescriptor;
+import nl.digitalekabeltelevisie.data.mpeg.psi.*;
+import nl.digitalekabeltelevisie.data.mpeg.psi.EITsectionATSC.Event;
+import nl.digitalekabeltelevisie.data.mpeg.psi.STT;
+import nl.digitalekabeltelevisie.gui.utils.GuiUtils;
+import nl.digitalekabeltelevisie.util.Utils;
+
+/**
+ * Class to create a grid image of EIT information, like the EPG in decoders.
+ *
+ *  Can be used from DVBTree as ImageSource, to show the contents of a single tableID (like 0x4E for present/following actual),
+ *  or as a JPanel with combined EIT information (current and other streams combined) , complete with scrollbars, mouse overs, zooming, switching between p/f and schedule.
+ * @author Eric
+ *
+ */
+public class EITATSCtableImage extends JPanel implements ComponentListener,ImageSource, Scrollable{
+
+    private static final Logger	logger	= Logger.getLogger(EITableImage.class.getName());
+    private static final String FONT_NAME = "SansSerif";   //字体类型
+    private static final int LINE_HEIGHT = 20;
+    private static final long DEFAULT_MILLI_SECS_PER_PIXEL = 30*1000;
+    private static final int SERVICE_NAME_WIDTH = 150;
+    private static final int LEGEND_HEIGHT = 40;
+
+
+    private EITATSC eit;
+    private long milliSecsPerPixel = DEFAULT_MILLI_SECS_PER_PIXEL;
+    private TreeMap<Integer, List<EITsectionATSC>> map_sourceID_eitList;
+
+    private TreeMap<Integer, List<ETTsection>> source_id_ettList;
+
+    private List<TVCTsection> tvcTsectionList;
+
+    private BigInteger offset;
+
+    private boolean selectedSchedule = true;
+
+    private final SimpleDateFormat tf = new SimpleDateFormat("HH:mm:ss");
+    private final SimpleDateFormat df = new SimpleDateFormat("yyyy/MM/dd");
+
+    private int translatedX;
+    private int translatedY;
+
+
+    /** dinghang.men
+     *  Constructor for use from DVBTree, for use as ImageSource
+     *
+     * @param
+     * @param
+     */
+    public EITATSCtableImage(EITATSC eitatsc, TreeMap<Integer, List<EITsectionATSC>> map, List<TVCTsection> list, TreeMap<Integer, List<ETTsection>> source_id_ettList){
+        this.eit = eitatsc;
+        this.map_sourceID_eitList = map;
+        this.tvcTsectionList = list;
+        this.milliSecsPerPixel = DEFAULT_MILLI_SECS_PER_PIXEL;
+        this.source_id_ettList = source_id_ettList;
+    }
+
+
+    /**
+     * Constructor for use from EITPanel, for use as JPanel
+     *
+     * @param stream
+     * @param viewContext
+     */
+    public EITATSCtableImage(final TransportStream stream, final ViewContext viewContext) {
+        super();
+        this.addComponentListener(this);
+        this.milliSecsPerPixel =15*1000L; // default for Jpanel, zoomlevel = 2
+
+        setTransportStream(stream, viewContext);
+        setToolTipText("");
+        revalidate();
+
+    }
+
+    /** dinghang.men
+     * To load a new TransportStream, forces update
+     * @param stream
+     * @param viewContext
+     */
+    public final void setTransportStream(final TransportStream stream, final ViewContext viewContext) {
+
+        if(stream!=null){
+            eit = stream.getPsi().getEitatsc();
+            this.map_sourceID_eitList = eit.getFlatEit();
+            TVCT tvct = stream.getPsi().getTvct();
+            this.tvcTsectionList = tvct.getTvctSectionList();
+            ETT ett = stream.getPsi().getEtt();
+            this.source_id_ettList = ett.getSourceId_ettList();
+            STT stt = stream.getPsi().getStt();
+            this.offset = stt.get_offset();
+        } else {
+            eit = null;
+        }
+        setSize(getDimension());
+        repaint();
+    }
+
+    /* (non-Javadoc)
+     * @see nl.digitalekabeltelevisie.gui.ImageSource#getImage()
+     */
+    @Override
+    public BufferedImage getImage() {
+
+//         determines selection and order of services to be rendered
+
+        if(map_sourceID_eitList == null){ // There is a set of EIT sections, but no events found. nothing to draw
+            return null;
+        }
+
+        // Round up/down to nearest hour
+//        Date startDate = roundHourDown(interval.getStart());
+//        Date endDate = roundHourUp(interval.getEnd());
+        BigInteger first_event_start_time = EITATSC.get_first_event_start_time(map_sourceID_eitList);
+        BigInteger last_event_end_time = EITATSC.get_last_event_end_time(map_sourceID_eitList);
+
+        int total_length = last_event_end_time.subtract(first_event_start_time).intValue();
+
+        int total_high = 0;
+        for (TVCTsection tvcTsection : tvcTsectionList) {
+            List<TVCTsection.VirtualChannel> virtualChannelList = tvcTsection.getVirtualChannelList();
+            for (TVCTsection.VirtualChannel virtualChannel : virtualChannelList) {
+                total_high ++;
+            }
+        }
+
+        int legendHeight = 40;
+        int height = (total_high * LINE_HEIGHT)+1 + LEGEND_HEIGHT;
+        int width = 1 + SERVICE_NAME_WIDTH + (int)(total_length*1000/milliSecsPerPixel);
+
+
+        long size = (long)width * height;
+        if (size > Integer.MAX_VALUE) {
+            return GuiUtils.getErrorImage("The combination of number of services and time interval\n"+
+                    "is too large to display.");
+        }
+
+
+        final BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
+        final Graphics2D gd = img.createGraphics();
+        gd.setColor(Color.BLUE);
+        gd.fillRect(0, 0, width, height);
+        gd.setColor(Color.WHITE);
+
+        final Font font = new Font(FONT_NAME, Font.PLAIN, 14);
+        final Font nameFont = new Font(FONT_NAME, Font.BOLD, 14);
+        gd.setFont(font);
+
+        BasicStroke basicStroke = new BasicStroke( 3.0f);
+        gd.setStroke(basicStroke);
+
+        drawLegend(gd,SERVICE_NAME_WIDTH,0, LEGEND_HEIGHT);
+        drawActualTime(gd, first_event_start_time ,SERVICE_NAME_WIDTH, 0, LEGEND_HEIGHT);
+
+        BasicStroke basicStroke1 = new BasicStroke( 1.0f);
+        gd.setStroke(basicStroke1);
+
+        int offset = LEGEND_HEIGHT;
+        int char_descend = 16;
+
+        // draw labels
+        drawLabels(gd, tvcTsectionList, nameFont, 0, offset, char_descend);
+
+        // draw grid
+        offset = LEGEND_HEIGHT;
+
+        gd.setFont(font);
+
+
+        for (Map.Entry<Integer, List<EITsectionATSC>> entry : map_sourceID_eitList.entrySet()) {
+            List<EITsectionATSC> eiTsectionATSCList = entry.getValue();
+            drawChannelEvents(gd,first_event_start_time,SERVICE_NAME_WIDTH,offset,char_descend,eiTsectionATSCList);
+            offset+=LINE_HEIGHT;
+        }
+
+        return img;
+    }
+
+
+    /**  dinghang.men
+     * Draw all events for a single service
+     *
+     * @param gd
+     * @param
+     * @param x
+     * @param y
+     * @param char_descend
+     * @param
+     */
+    private void drawChannelEvents(final Graphics2D gd, BigInteger frist_time,int x, int y, int char_descend,
+                                   List<EITsectionATSC> eiTsectionATSCList) {
+
+        for (EITsectionATSC eiTsectionATSC : eiTsectionATSCList) {
+            if(eiTsectionATSC != null){
+                List<Event> eventList = eiTsectionATSC.getEventList();
+                for (Event event : eventList) {
+                    drawEvent(gd,frist_time,event,x,y,char_descend);
+                }
+            }
+        }
+
+    }
+
+
+    /**  dinghang.men
+     * Draw single event
+     *
+     * @param gd
+     * @param
+     * @param event
+     * @param x
+     * @param y
+     * @param char_descend
+     */
+    private void drawEvent(final Graphics2D gd, BigInteger startTime, Event event, int x, int y, int char_descend) {
+        final BigInteger eventStartTime = event.getStart_time();
+        int length_in_seconds = event.getLength_in_seconds();
+
+        try{
+            int w = (int)(length_in_seconds*1000/milliSecsPerPixel);
+
+            int temp ;
+            if(eventStartTime.compareTo(startTime) >= 0){
+                temp = eventStartTime.subtract(startTime).intValue();
+            }else{
+                temp = 0;
+            }
+
+            int mill = (int)milliSecsPerPixel;
+            int eventX = x+(int)(temp*1000/milliSecsPerPixel);
+
+            MSSdescriptor firstMSS = event.getTitle_text().getFirst();
+            MSSdescriptor.DescriptorString firstDS = firstMSS.getDescriptorStringList().getFirst();
+            MSSdescriptor.DescriptorString.DescriptorSegment firstSeg = firstDS.getSegmentList().getFirst();
+            byte[] compressedStringByte = firstSeg.getCompressed_string_byte();
+
+            String eventName = Utils.hexToAsciiString(compressedStringByte);
+
+            // FIll gray
+            gd.setColor(Color.GRAY);
+            gd.fillRect(eventX, y, w, LINE_HEIGHT);
+
+            // black border
+            gd.setColor(Color.BLACK);
+            gd.drawRect(eventX, y, w, LINE_HEIGHT);
+            // title
+
+
+            Graphics2D gd2 = (Graphics2D)gd.create();
+            gd2.clipRect(eventX+5, y, w-10, LINE_HEIGHT);
+
+            gd2.setColor(Color.WHITE);
+            gd2.drawString(eventName, eventX+5,y+char_descend);
+            gd2.dispose();
+        }catch(NumberFormatException nfe){
+            logger.log(Level.WARNING, "drawEvent: Event.duration is not a valid BCD number;", nfe);
+
+        }
+    }
+
+
+
+    /**  dinghang.men
+     * Draws a column with service names at the left of the image
+     * If no name found in SDT put "Service " + service ID.
+     *
+     * @param gd
+     * @param
+     * @param nameFont
+     * @param x
+     * @param y
+     * @param char_descend
+     */
+    private void drawLabels(final Graphics2D gd, List<TVCTsection> tvcTsectionList, final Font nameFont,
+                            int x,  int y, int char_descend) {
+        int labelY = y;
+        gd.setFont(nameFont);
+
+        Map<Integer,String> source_id_short_name = new TreeMap<>();
+
+        for (TVCTsection tvcTsection : tvcTsectionList) {
+            List<TVCTsection.VirtualChannel> virtualChannelList = tvcTsection.getVirtualChannelList();
+            for (TVCTsection.VirtualChannel virtualChannel : virtualChannelList) {
+                if(!source_id_short_name.containsKey(virtualChannel.getSource_id())){
+                    source_id_short_name.put(virtualChannel.getSource_id(),
+                            TVCTsection.explain_short_name(virtualChannel.getShort_name()));
+                }
+            }
+        }
+
+//        Set<Integer> source_id_list = source_id_short_name.keySet();
+
+        for(Map.Entry<Integer, String> entry : source_id_short_name.entrySet()){
+            String channel_name = entry.getValue();
+            gd.setColor(Color.BLUE);
+            gd.fillRect(x, labelY, SERVICE_NAME_WIDTH, LINE_HEIGHT);
+            gd.setColor(Color.WHITE);
+            Graphics2D gd2 = (Graphics2D)gd.create();
+
+            gd2.clipRect(x, labelY, SERVICE_NAME_WIDTH-10, LINE_HEIGHT);
+            gd2.drawString(channel_name, x+5, labelY+char_descend);
+            gd2.dispose();
+
+            labelY+=LINE_HEIGHT;
+        }
+    }
+
+
+    /**  dinghang.men
+     * draws a vertical red line in the legend at the location of the 'current' (first TDT) time of the stream.
+     *
+     * @param gd
+     * @param
+     * @param x
+     * @param y
+     * @param legendHeight
+     */
+    private void drawActualTime(final Graphics2D gd, BigInteger frist_time,int x, int y, int legendHeight) {
+        // do we have a current time in the TDT?
+        if(this.eit.getParentPSI().getStt()!=null){
+
+            List<STTsection> sttSectionList = this.eit.getParentPSI().getStt().getSttSectionList();
+            if(!sttSectionList.isEmpty()){
+                STTsection first = sttSectionList.getFirst();
+                BigInteger systemTime = first.getSystem_time_BigInteger();
+                BigInteger gpsUtcOffset = first.getGPS_UTC_offset_BigInteger();
+                if(systemTime!=null){
+                    gd.setColor(Color.RED);
+                    int temp = systemTime.subtract(frist_time).subtract(gpsUtcOffset).intValue();
+                    int labelX = x+(int)((temp * 1000)/milliSecsPerPixel);
+                    gd.drawLine(labelX, y, labelX, (y+legendHeight)-1);
+                }
+            }
+        }
+    }
+
+
+    /**  dinghang.men
+     * The legend is the black horizontal bar at the top of the image, with the vertical white lines and printed time/date at every hour
+     *
+     * @param gd Graphics2D to draw on
+     * @param
+     * @param
+     * @param x position on image
+     * @param y position on image
+     * @param legendHeight height of bar
+     */
+    private void drawLegend(final Graphics2D gd, int x, int y, int legendHeight) {
+        gd.setColor(Color.BLACK);
+
+        BigInteger firstEventStartTime = EITATSC.get_first_event_start_time(map_sourceID_eitList);
+        BigInteger lastEventEndTime = EITATSC.get_last_event_end_time(map_sourceID_eitList);
+        int temp = lastEventEndTime.subtract(firstEventStartTime).subtract(offset).intValue();
+
+        int w = (int)((temp * 1000)/milliSecsPerPixel);
+        gd.fillRect(x, y, w, legendHeight);
+
+        gd.setColor(Color.WHITE);
+
+        BigInteger hourMark = firstEventStartTime;
+        BigInteger oneHour = new BigInteger("3600");
+        while(hourMark.compareTo(lastEventEndTime) <= 0){
+            int temp2 = hourMark.subtract(firstEventStartTime).intValue();
+            int labelX = x+(int)((temp2 * 1000)/milliSecsPerPixel);
+            gd.drawLine(labelX, y, labelX, (legendHeight-1)+y);
+
+
+            String date_time_String =   STTsection.convertGpsTimeToUtc(hourMark,offset);
+
+            String dateString =   date_time_String.substring(0,10);
+            String timeString = date_time_String.substring(10);
+
+            gd.drawString(dateString, labelX+5, y+ 17);
+            gd.drawString(timeString, labelX+5, y+ 37);
+
+            hourMark = hourMark.add(oneHour); //advance 1 hour
+        }
+    }
+
+    /** dinghang.men
+     * Size of image (including labels and legend) to be drawn, depending on interval covered by events, number of services and milliseconds per pixel
+     *
+     * @return
+     */
+    public final Dimension getDimension(){
+        if((eit != null )&&(tvcTsectionList != null)){
+
+            try{
+                // Round up/down to nearest hour
+                int total_length = 0;
+
+                BigInteger first_event_start_time = EITATSC.get_first_event_start_time(map_sourceID_eitList);
+                BigInteger last_event_end_time = EITATSC.get_last_event_end_time(map_sourceID_eitList);
+
+                total_length = last_event_end_time.subtract(first_event_start_time).intValue();
+
+
+                int total_high = 0;
+                for (TVCTsection tvcTsection : tvcTsectionList) {
+                    List<TVCTsection.VirtualChannel> virtualChannelList = tvcTsection.getVirtualChannelList();
+//                total_high += virtualChannelList.size();
+                    for (TVCTsection.VirtualChannel virtualChannel : virtualChannelList) {
+                        total_high ++;
+                    }
+                }
+
+
+                int legendHeight = 40;
+                int height = (total_high * LINE_HEIGHT)+1 + legendHeight;
+                int width = 1 + SERVICE_NAME_WIDTH + (int)(total_length*1000/milliSecsPerPixel);
+                return new Dimension(width,height);
+            }catch (IndexOutOfBoundsException e){
+                return new Dimension(0,0);
+            }
+        }
+        return new Dimension(0,0);
+    }
+
+
+    /**
+     * Determines width in pixels of events.
+     * width = event duration (in milliseconds) /  milliSecsPerPixel
+     *
+     * So if event lasts 45 minutes (45*60*1000 = 2700000 milliseconds) and milliSecsPerPixel == 30*1000 (30000)
+     * the event will display with a width of 90 pixels.
+     *
+     * @param milliSecsPerPixel
+     */
+    public void setMilliSecsPerPixel(long milliSecsPerPixel) {
+        this.milliSecsPerPixel = milliSecsPerPixel;
+    }
+
+    @Override
+    public String getToolTipText(final MouseEvent e){
+        StringBuilder r1 = new StringBuilder();
+        if((eit!=null)&&(tvcTsectionList != null)&&(!source_id_ettList.isEmpty())){
+            final int x=e.getX();
+            final int y=e.getY();
+            if( y>(translatedY+LEGEND_HEIGHT)){ // mouse not over legend?
+
+                int row = (y-LEGEND_HEIGHT)/LINE_HEIGHT;
+                if(row<tvcTsectionList.getFirst().getVirtualChannelList().size()){ // not below last line
+                    r1.append("<html><b>");
+//                    r1.append("ATSC TEXT");
+                    int source_id = tvcTsectionList.getFirst().getVirtualChannelList().get(row).getSource_id();
+                    if(x>(translatedX+SERVICE_NAME_WIDTH)) { // over event line
+                        long temp = milliSecsPerPixel * (x - SERVICE_NAME_WIDTH);
+                        temp = temp/1000;
+                        BigInteger time = BigInteger.valueOf(temp);
+                        BigInteger first_event_start_time = EITATSC.get_first_event_start_time(map_sourceID_eitList);
+                        BigInteger now = time.add(first_event_start_time);
+                        Event event = findEvent(source_id, now);
+                        int need_event_id = -1;
+                        if(event != null){
+                            need_event_id = event.getEvent_id();
+                        }
+                        List<ETTsection> list = source_id_ettList.get(source_id);
+                        for (ETTsection item : list) {
+                            byte[] etm_id = item.getETM_id();
+                            int event_id = Utils.getBitsFromByteArray(etm_id,16,14);
+                            if(need_event_id == event_id){
+//                                byte[] compressedStringByte = item.getExtended_text_message().getFirst().getDescriptorStringList().getFirst().getSegmentList().getFirst().getCompressed_string_byte();
+//                                String text = Utils.hexToAsciiString(compressedStringByte);
+                                String text = MSSdescriptor.get_multi_string(item.getExtended_text_message());
+                                try{
+                                    int start = 0; // 每个substring操作的起始索引
+                                    while (start + 100 < text.length()) { // 当剩余字符超过50时
+                                        r1.append(text.substring(start, start + 100)).append("<br><br>"); // 提取并追加下一个50字符段
+                                        start += 100; // 更新下一段的起始索引
+                                    }
+                                    r1.append(text.substring(start));
+                                }catch (RuntimeException err){
+                                    break;
+                                }
+                                r1.append("</b><br><br>");
+                                break;
+                            }
+                        }
+                    }else { // over service names
+                        List<ETTsection> list = source_id_ettList.get(source_id);
+                        for (ETTsection item : list) {
+                            byte[] etm_id = item.getETM_id();
+                            int event_id = Utils.getBitsFromByteArray(etm_id,30,2);
+                            if( event_id == 0){
+//                                byte[] compressedStringByte = item.getExtended_text_message().getFirst().getDescriptorStringList().getFirst().getSegmentList().getFirst().getCompressed_string_byte();
+//                                String text = Utils.hexToAsciiString(compressedStringByte);
+                                String text = MSSdescriptor.get_multi_string(item.getExtended_text_message());
+                                try{
+                                    int start = 0; // 每个substring操作的起始索引
+                                    while (start + 100 < text.length()) { // 当剩余字符超过50时
+                                        r1.append(text.substring(start, start + 100)).append("<br><br>"); // 提取并追加下一个50字符段
+                                        start += 100; // 更新下一段的起始索引
+                                    }
+                                    r1.append(text.substring(start));
+                                }catch (RuntimeException err){
+                                    break;
+                                }
+                                r1.append("</b><br><br>");
+                                break;
+                            }
+                        }
+                    }
+                    r1.append("</html>");
+                }
+            }
+        }
+        return r1.toString();
+    }
+
+    /**  dinghang.men
+     * Find event in servicesTable, based on serviceID, and date
+     *
+     * @param
+     * @param
+     * @return
+     */
+    private Event findEvent(Integer source_id, BigInteger now){
+        List<EITsectionATSC> eiTsectionATSCList = map_sourceID_eitList.get(source_id);
+        for (EITsectionATSC eiTsectionATSC : eiTsectionATSCList) {
+            List<Event> eventList = eiTsectionATSC.getEventList();
+            for (Event event : eventList) {
+                if(now.compareTo(event.getStart_time()) >= 0){
+                    BigInteger length = BigInteger.valueOf(event.getLength_in_seconds());
+                    BigInteger end = event.getStart_time().add(length);
+                    if(now.compareTo(end) <=0 ){
+                        return event;
+                    }
+
+                }
+            }
+        }
+        return null;
+    }
+
+
+    /* (non-Javadoc)
+     * @see java.awt.event.ComponentListener#componentHidden(java.awt.event.ComponentEvent)
+     */
+    public void componentHidden(final ComponentEvent e) {
+        // empty block
+
+    }
+
+    /* (non-Javadoc)
+     * @see java.awt.event.ComponentListener#componentMoved(java.awt.event.ComponentEvent)
+     */
+    public void componentMoved(final ComponentEvent e) {
+        repaint();
+    }
+
+    /* (non-Javadoc)
+     * @see java.awt.event.ComponentListener#componentResized(java.awt.event.ComponentEvent)
+     */
+    public void componentResized(final ComponentEvent e) {
+        repaint();
+    }
+
+    /* (non-Javadoc)
+     * @see java.awt.event.ComponentListener#componentShown(java.awt.event.ComponentEvent)
+     */
+    public void componentShown(final ComponentEvent e) {
+        repaint();
+    }
+
+    /**
+     * Paints the table for the JPanel usage, with the legend and labels always in view.
+     *
+     * @see javax.swing.JComponent#paintComponent(java.awt.Graphics)
+     */
+    @Override
+    public void paintComponent(final Graphics g) {
+        setBackground(Color.BLUE);
+        super.paintComponent(g);    // paints background
+
+        Graphics2D gd = (Graphics2D)g;
+        gd.setColor(Color.BLACK);
+
+        Rectangle rect = getVisibleRect();
+        translatedX = rect.x;
+        translatedY = rect.y;
+        int viewWidth = rect.width;
+        int viewHeight = rect.height;
+
+        if(eit!=null){ // there are services in the EIT
+            BigInteger first_event_start_time = EITATSC.get_first_event_start_time(map_sourceID_eitList);
+            BigInteger last_event_end_time = EITATSC.get_last_event_end_time(map_sourceID_eitList);
+
+            gd.setColor(Color.WHITE);
+
+            final Font font = new Font(FONT_NAME, Font.PLAIN, 14);
+            final Font nameFont = new Font(FONT_NAME, Font.BOLD, 14);
+            gd.setFont(font);
+
+            BasicStroke basicStroke = new BasicStroke( 3.0f);
+            gd.setStroke(basicStroke);
+
+
+            BasicStroke basicStroke1 = new BasicStroke( 1.0f);
+            gd.setStroke(basicStroke1);
+
+            int offset = LEGEND_HEIGHT;
+            int char_descend = 16;
+            drawLegend(gd, SERVICE_NAME_WIDTH,translatedY, LEGEND_HEIGHT);
+            drawActualTime(gd, first_event_start_time,SERVICE_NAME_WIDTH, translatedY,LEGEND_HEIGHT);
+
+            // draw labels
+            drawLabels(gd, tvcTsectionList, nameFont, translatedX, offset, char_descend);
+
+            gd.setColor(Color.BLUE);
+            gd.fillRect(translatedX, translatedY, SERVICE_NAME_WIDTH, LEGEND_HEIGHT);
+
+            // draw grid
+            offset=LEGEND_HEIGHT;
+            Graphics2D gd2 = (Graphics2D)gd.create();
+
+            gd2.setFont(font);
+            gd2.clipRect(translatedX+SERVICE_NAME_WIDTH, translatedY+LEGEND_HEIGHT, viewWidth -SERVICE_NAME_WIDTH, viewHeight - LEGEND_HEIGHT);
+
+            for (Map.Entry<Integer, List<EITsectionATSC>> entry : map_sourceID_eitList.entrySet()) {
+                List<EITsectionATSC> eiTsectionATSCList = entry.getValue();
+                drawChannelEvents(gd2,first_event_start_time,SERVICE_NAME_WIDTH,offset,char_descend,eiTsectionATSCList);
+                offset+=LINE_HEIGHT;
+            }
+
+            gd2.dispose();
+
+        }else{
+            gd.setColor(Color.WHITE);
+            final Font nameFont = new Font(FONT_NAME, Font.BOLD, 14);
+            gd.setFont(nameFont);
+            gd.drawString("No EIT present (or empty)", 20, 20);
+        }
+
+    }
+
+//
+//    /**
+//     *
+//     * Causes display to switch to Present/following information for all services in entire EIT.
+//     *
+//     *  Used for display as JPanel.
+//     *
+//     */
+//    public void selectPresentFollowing() {
+//        selectedSchedule = false;
+//        if(eit!=null){
+//            servicesTable = eit.getCombinedPresentFollowing();
+//            serviceOrder = new TreeSet<>(servicesTable.keySet());
+//            interval = EIT.getSpanningInterval(serviceOrder, servicesTable);
+//            setSize(getDimension());
+//            repaint();
+//        }
+//    }
+//
+//    /**
+//     *
+//     * Causes display to switch to schedule information for all services in entire EIT.
+//     *
+//     *  Used for display as JPanel.
+//     *
+//     */
+//    public void selectSchedule() {
+//        selectedSchedule = true;
+//        if(eit!=null){
+//            servicesTable = eit.getCombinedSchedule();
+//            serviceOrder = new TreeSet<>(servicesTable.keySet());
+//            interval = EIT.getSpanningInterval(serviceOrder, servicesTable);
+//            setSize(getDimension());
+//            repaint();
+//        }
+//    }
+//
+    /**
+     * Determines width of events
+     *
+     * @param l milliseconds per pixel
+     */
+    public void setZoom(long l) {
+        milliSecsPerPixel = l;
+        setSize(getDimension());
+        repaint();
+    }
+
+    @Override
+    public Dimension getPreferredSize() {
+        return getDimension();
+    }
+
+
+    /* (non-Javadoc)
+     * @see javax.swing.Scrollable#getPreferredScrollableViewportSize()
+     */
+    @Override
+    public Dimension getPreferredScrollableViewportSize() {
+        return getPreferredSize();
+    }
+
+
+    /* (non-Javadoc)
+     * @see javax.swing.Scrollable#getScrollableUnitIncrement(java.awt.Rectangle, int, int)
+     */
+    @Override
+    public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction) {
+        if (orientation == SwingConstants.HORIZONTAL){
+            // 1 hour
+            return (int) ((60 * 60 * 1000) / milliSecsPerPixel);
+        }
+        // single line
+        return LINE_HEIGHT;
+    }
+
+
+    /* (non-Javadoc)
+     * @see javax.swing.Scrollable#getScrollableBlockIncrement(java.awt.Rectangle, int, int)
+     */
+    @Override
+    public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction) {
+        if (orientation == SwingConstants.HORIZONTAL){
+            //
+            final int w = (int)getVisibleRect().getWidth()-SERVICE_NAME_WIDTH;
+            // round down to integer number of hours, at least 1 hour
+            int pixelsHour = (int) ((60 * 60 * 1000) / milliSecsPerPixel);
+            return Math.max(pixelsHour, w-(w%pixelsHour));
+        }
+        final int h = (int)getVisibleRect().getHeight()-LEGEND_HEIGHT;
+        // round down to integer number of services
+        return h-(h%LINE_HEIGHT);
+    }
+
+
+    /* (non-Javadoc)
+     * @see javax.swing.Scrollable#getScrollableTracksViewportWidth()
+     */
+    @Override
+    public boolean getScrollableTracksViewportWidth() {
+        return (eit==null);
+    }
+
+
+    /* (non-Javadoc)
+     * @see javax.swing.Scrollable#getScrollableTracksViewportHeight()
+     */
+    @Override
+    public boolean getScrollableTracksViewportHeight() {
+        return (eit==null);
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/nl/digitalekabeltelevisie/gui/EITView.java b/src/main/java/nl/digitalekabeltelevisie/gui/EITView.java
index 1806b49..d51c5d8 100644
--- a/src/main/java/nl/digitalekabeltelevisie/gui/EITView.java
+++ b/src/main/java/nl/digitalekabeltelevisie/gui/EITView.java
@@ -2,7 +2,8 @@
  *
  *  http://www.digitalekabeltelevisie.nl/dvb_inspector
  *
- *  This code is Copyright 2009-2019 by Eric Berendsen (e_berendsen@digitalekabeltelevisie.nl)
+ *  This code is Copyright 2009-2019 by Eric Berendsen (e_berendsen@
+ digitalekabeltelevisie.nl)
  *
  *  This file is part of DVB Inspector.
  *
@@ -49,23 +50,26 @@ public class EITView extends JPanel implements TransportStreamView{
 	 * @param transportStream
 	 * @param viewContext
 	 */
-	public EITView(final TransportStream transportStream, final ViewContext viewContext) {
+	public EITView(final TransportStream transportStream, final ViewContext
+			viewContext) {
 		super(new BorderLayout());
 		eitPanel = new EITableImage(transportStream,viewContext);
 		/**
 		 *
 		 */
 		JScrollPane scrollGrid = new JScrollPane(eitPanel);
-		scrollGrid.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
-		scrollGrid.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
+		scrollGrid.setVerticalScrollBarPolicy(ScrollPaneConstants.
+				VERTICAL_SCROLLBAR_ALWAYS);
+		scrollGrid.setHorizontalScrollBarPolicy(ScrollPaneConstants.
+				HORIZONTAL_SCROLLBAR_ALWAYS);
 
 		createCopySaveButtonBar();
-		
+
 		toolbar.add(Box.createHorizontalStrut(50));
 		addPfScheduleRadioButtons();
 		toolbar.add(Box.createHorizontalStrut(50)); // spacer
 		addZoomRadioButtons();
-		
+
 		add(toolbar,BorderLayout.PAGE_START);
 		add(scrollGrid,BorderLayout.CENTER);
 	}
@@ -79,7 +83,8 @@ public class EITView extends JPanel implements TransportStreamView{
 		getActionMap().put("copy", copyAction);
 		toolbar.add(copyButton);
 
-		ImageSaveAction saveAction = new ImageSaveAction(this, "Save As...",eitPanel);
+		ImageSaveAction saveAction = new ImageSaveAction(this, "Save As...",eitPanel
+		);
 		JButton saveButton = new JButton(saveAction);
 		KeyStroke saveKey = KeyStroke.getKeyStroke(KeyEvent.VK_S,Event.CTRL_MASK);
 		getInputMap(WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(saveKey, "save");
@@ -126,11 +131,12 @@ public class EITView extends JPanel implements TransportStreamView{
 		toolbar.add(zoom2Button);
 		toolbar.add(zoom3Button);
 	}
-	
+
 	/* (non-Javadoc)
 	 * @see nl.digitalekabeltelevisie.gui.TransportStreamView#setTransportStream(nl.digitalekabeltelevisie.data.mpeg.TransportStream, nl.digitalekabeltelevisie.controller.ViewContext)
 	 */
-	public void setTransportStream(final TransportStream transportStream, final ViewContext viewContext) {
+	public void setTransportStream(final TransportStream transportStream, final
+	ViewContext viewContext) {
 
 		eitPanel.setTransportStream(transportStream,viewContext);
 		validate();
diff --git a/src/main/java/nl/digitalekabeltelevisie/gui/EITableImage.java b/src/main/java/nl/digitalekabeltelevisie/gui/EITableImage.java
index 5b53d9b..c39e0a2 100644
--- a/src/main/java/nl/digitalekabeltelevisie/gui/EITableImage.java
+++ b/src/main/java/nl/digitalekabeltelevisie/gui/EITableImage.java
@@ -157,6 +157,7 @@ public class EITableImage extends JPanel implements ComponentListener,ImageSourc
 		}
 		setSize(getDimension());
 		repaint();
+
 	}
 
 	/* (non-Javadoc)
diff --git a/src/main/java/nl/digitalekabeltelevisie/main/DVBinspector.java b/src/main/java/nl/digitalekabeltelevisie/main/DVBinspector.java
index 46e5a07..3fca664 100644
--- a/src/main/java/nl/digitalekabeltelevisie/main/DVBinspector.java
+++ b/src/main/java/nl/digitalekabeltelevisie/main/DVBinspector.java
@@ -242,7 +242,7 @@ public class DVBinspector implements ChangeListener, ActionListener{
 
 		ToolTipManager.sharedInstance().setDismissDelay(30000);
 		//Create and set up the window.
-		frame = new JFrame("DVB Inspector");
+		frame = new JFrame("DVB/ATSC Inspector");
 		frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
 		frame.addWindowListener(new WindowAdapter() {
 			/* (non-Javadoc)
@@ -290,6 +290,11 @@ public class DVBinspector implements ChangeListener, ActionListener{
 		tabbedPane.setMnemonicAt(5, KeyEvent.VK_6);
 		views.add(timeStampChart);
 
+		final EITATSCView eitatscView = new EITATSCView(tStream,viewContext);
+		tabbedPane.addTab("ATSC EIT View", eitatscView);
+		views.add(eitatscView);
+		tabbedPane.setMnemonicAt(6, KeyEvent.VK_6);
+
 		tabbedPane.validate();
 		tabbedPane.addChangeListener(this);
 		
@@ -634,7 +639,7 @@ public class DVBinspector implements ChangeListener, ActionListener{
 		this.transportStream = transportStream;
 		if(transportStream!=null){
 			updatePIDLists(transportStream,pidDialog);
-			frame.setTitle(transportStream.getFile().getName()+ " - stream:"+ transportStream.getStreamID()+ " - DVB Inspector");
+			frame.setTitle(transportStream.getFile().getName()+ " - stream:"+ transportStream.getStreamID()+ " - DVB/ATSC Inspector");
 		}
 
 		for(final TransportStreamView v: views) {
diff --git a/src/main/java/nl/digitalekabeltelevisie/util/Utils.java b/src/main/java/nl/digitalekabeltelevisie/util/Utils.java
index f5e022a..1737d59 100644
--- a/src/main/java/nl/digitalekabeltelevisie/util/Utils.java
+++ b/src/main/java/nl/digitalekabeltelevisie/util/Utils.java
@@ -485,6 +485,11 @@ public final class Utils {
 		return (( b & (0x80 >> (i-1))));
 	}
 
+	//dinghang.men
+	public static int getBitATSC(final byte b, final int index) {
+		return (b & (0x80 >> index)) == 0 ? 0 : 1;
+	}
+
 	/**
 	 * Get sequence of bits from a byte
 	 * @param b
@@ -505,6 +510,65 @@ public final class Utils {
 		return (b & mask) >> (9 - i - len);
 	}
 
+	//dinghang.men
+	public static int getBitsATSC(final byte b, final int start_index, final int len) {
+		int mask = (0xFF >> start_index) & (0xFF << (8 - (start_index + len)));
+		return (b & mask) >>> (8 - start_index - len);
+	}
+
+	//dinghang.men
+	public static int getBitsFromByteArray(byte[] bytes, int bitIndex, int len) {
+		int byteIndex = bitIndex / 8; // 计算位序列开始的字节索引
+		int startBitInByte = bitIndex % 8; // 计算位序列开始的位在其字节内的位置
+		int endBitIndex = bitIndex + len - 1; // 计算位序列结束的全局位索引
+		int endByteIndex = endBitIndex / 8; // 计算位序列结束的字节索引
+
+		// 用于累积结果的变量
+		int result = 0;
+
+		// 循环遍历位序列涉及的每个字节
+		for (int i = byteIndex; i <= endByteIndex; i++) {
+			int currentByte = bytes[i] & 0xFF; // 将当前字节转换为无符号整数
+			int bitsToUse = 8; // 默认情况下，我们将使用当前字节的所有8位
+
+			// 如果我们在序列的开始字节，调整掩码，忽略掉前面不需要的位
+			if (i == byteIndex) {
+				currentByte <<= startBitInByte;
+				bitsToUse -= startBitInByte;
+			}
+
+			// 如果我们在序列的最后一个字节，进一步调整掩码，忽略掉后面不需要的位
+			int bitsInEndByte = (endBitIndex % 8) + 1;
+			if (i == endByteIndex && bitsInEndByte < 8) {
+				currentByte &= (0xFF << (8 - bitsInEndByte));
+				bitsToUse = Math.min(bitsToUse, bitsInEndByte);
+			}
+
+			// 将当前字节的贡献加到结果中，需要注意的是，我们可能需要左移结果
+			result <<= bitsToUse;
+			result |= (currentByte & 0xFF) >>> (8 - bitsToUse);
+		}
+
+		// 返回提取的位序列
+		return result;
+	}
+
+	//dinghang.men
+	public static String hexToAsciiString(byte[] hexBytes) {
+		// 使用StringBuilder来构建最终的字符串
+		StringBuilder stringBuilder = new StringBuilder();
+
+		// 遍历字节数据
+		for (byte b : hexBytes) {
+			// 将每个字节转换为相应的ASCII字符并添加到StringBuilder中
+			stringBuilder.append((char) b);
+		}
+
+		// 返回构建好的字符串
+		return stringBuilder.toString();
+	}
+
+
 	/**
 	 * Convert byte[] into string with BCD representation. Each byte consists of two nibbles.
 	 * Real BCD should only contain values 0 - 9 in each nibble. 0xA - 0xF are illegal. This method will allow them but log an error.
